<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI RPG Game (Multi-Model)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; 
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; 
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        const { useState, useEffect, useRef } = React;

        // --- Configuration & Models ---

        const PROVIDERS = {
            GOOGLE: "google",
            OPENAI: "openai",
            DEEPSEEK: "deepseek",
            ANTHROPIC: "anthropic"
        };

        const AVAILABLE_MODELS = [
            // Google Models
            { id: "gemini-3-pro-preview", name: "Gemini 3.0 Pro Preview (Paid)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-2.5-pro", name: "Gemini 2.5 Pro (Thinking Model)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-2.0-pro-exp", name: "Gemini 2.0 Pro Exp (If Available)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-1.5-pro", name: "Gemini 1.5 Pro (Free Tier)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-1.5-flash", name: "Gemini 1.5 Flash (Fast)", provider: PROVIDERS.GOOGLE },
            // DeepSeek Models
            { id: "deepseek-chat", name: "DeepSeek V3 (Chat)", provider: PROVIDERS.DEEPSEEK },
            { id: "deepseek-reasoner", name: "DeepSeek R1 (Reasoner)", provider: PROVIDERS.DEEPSEEK },
            // Anthropic Models (Simulated Date: Nov 2025)
            { id: "claude-3-7-sonnet-20250219", name: "Claude 3.7 Sonnet (Latest)", provider: PROVIDERS.ANTHROPIC },
            { id: "claude-3-5-sonnet-20241022", name: "Claude 3.5 Sonnet", provider: PROVIDERS.ANTHROPIC },
            { id: "claude-3-opus-20240229", name: "Claude 3 Opus", provider: PROVIDERS.ANTHROPIC },
            // OpenAI / Compatible Models
            { id: "gpt-4o", name: "GPT-4o", provider: PROVIDERS.OPENAI },
            { id: "gpt-4-turbo", name: "GPT-4 Turbo", provider: PROVIDERS.OPENAI },
            { id: "gpt-3.5-turbo", name: "GPT-3.5 Turbo", provider: PROVIDERS.OPENAI },
            { id: "custom", name: "Custom Model ID", provider: PROVIDERS.OPENAI }
        ];

        const DEFAULT_CONFIG = {
            provider: PROVIDERS.GOOGLE,
            model: "gemini-2.5-pro",
            baseUrl: "https://generativelanguage.googleapis.com", // Default Google URL
            apiKey: ""
        };

        // --- AI Service Implementation ---

        const callAI = async (config, messages, jsonMode = true) => {
            const { provider, model, baseUrl, apiKey } = config;

            try {
                if (provider === PROVIDERS.GOOGLE) {
                    // --- Google Gemini API ---
                    let promptText = "";
                    messages.forEach(msg => {
                        promptText += `${msg.role === 'system' ? 'System Instruction' : 'User Input'}: ${msg.content}\n\n`;
                    });

                    // Use configured baseUrl (allows proxy usage)
                    // Ensure no trailing slash
                    const cleanBaseUrl = (baseUrl || "https://generativelanguage.googleapis.com").replace(/\/$/, "");
                    const url = `${cleanBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`;

                    const response = await fetch(url, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: promptText }] }],
                            generationConfig: {
                                responseMimeType: jsonMode ? "application/json" : "text/plain"
                            }
                        })
                    });

                    if (!response.ok) {
                        const err = await response.json().catch(() => ({}));
                        throw new Error(err.error?.message || `Google API Error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    if (!data.candidates || data.candidates.length === 0) throw new Error("No content generated");
                    const content = data.candidates[0].content.parts[0].text;
                    return jsonMode ? JSON.parse(content) : content;

                } else if (provider === PROVIDERS.ANTHROPIC) {
                    // --- Anthropic API ---
                    let url = baseUrl.replace(/\/$/, "");
                    if (!url.endsWith("/v1/messages")) {
                        url += "/v1/messages";
                    }

                    const systemMessage = messages.find(m => m.role === 'system')?.content || "";
                    const userMessages = messages.filter(m => m.role !== 'system').map(m => ({
                        role: m.role,
                        content: m.content
                    }));

                    const body = {
                        model: model,
                        max_tokens: 4096,
                        system: systemMessage,
                        messages: userMessages,
                        temperature: 0.7
                    };

                    // Note: Anthropic API requires CORS proxy or browser-specific handling
                    const response = await fetch(url, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "x-api-key": apiKey,
                            "anthropic-version": "2023-06-01",
                            "anthropic-dangerous-direct-browser-access": "true"
                        },
                        body: JSON.stringify(body)
                    });

                    if (!response.ok) {
                        const err = await response.json().catch(() => ({}));
                        throw new Error(err.error?.message || `Anthropic API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    const textBlock = data.content.find(b => b.type === 'text');
                    if (!textBlock) throw new Error("No text content in Anthropic response");
                    
                    const content = textBlock.text;
                    if (jsonMode) {
                        // Try to find JSON block
                        const jsonMatch = content.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            return JSON.parse(jsonMatch[0]);
                        }
                        return JSON.parse(content);
                    }
                    return content;

                } else {
                    // --- OpenAI Compatible API (DeepSeek / OpenAI) ---
                    let url = baseUrl.replace(/\/$/, "");
                    if (!url.endsWith("/chat/completions")) {
                        url += "/chat/completions";
                    }

                    const body = {
                        model: model === 'custom' ? 'gpt-3.5-turbo' : model, 
                        messages: messages,
                        temperature: 0.7,
                        response_format: jsonMode ? { type: "json_object" } : undefined
                    };

                    const response = await fetch(url, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(body)
                    });

                    if (!response.ok) {
                        const err = await response.json().catch(() => ({}));
                        throw new Error(err.error?.message || `API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    const content = data.choices[0].message.content;
                    return jsonMode ? JSON.parse(content) : content;
                }
            } catch (error) {
                console.error("AI Service Error:", error);
                throw error;
            }
        };

        // --- Prompts (Unchanged) ---

        const getCharGenPrompt = (worldview, description) => {
            return [
                {
                    role: "system",
                    content: `ä½ æ˜¯ä¸€ä½å¯Œæœ‰åˆ›é€ åŠ›çš„ RPG æ¸¸æˆä¸»æŒäºº (GM)ã€‚è¯·æ ¹æ®ç”¨æˆ·çš„è¾“å…¥åˆ›å»ºä¸€ä¸ªè§’è‰²ã€‚
                    é‡è¦æç¤ºï¼šæ‰€æœ‰é¢å‘ç”¨æˆ·çš„æ–‡æœ¬ï¼ˆå§“åã€èŒä¸šã€æŠ€èƒ½æè¿°ã€æ•…äº‹ï¼‰å¿…é¡»ä½¿ç”¨ç®€ä½“ä¸­æ–‡ã€‚
                    
                    ä»…è¿”å›ç¬¦åˆæ­¤ç»“æ„çš„æœ‰æ•ˆ JSONï¼š
                    {
                        "name": "string (ä¸­æ–‡å)",
                        "class": "string (ä¸­æ–‡èŒä¸šå)",
                        "stats": { 
                            "hp": number (50-1000), 
                            "maxHp": number (åŒ hp), 
                            "mp": number (0-1000), 
                            "maxMp": number (åŒ mp),
                            "stamina": number (0-100),
                            "maxStamina": number (åŒ stamina),
                            "attack": number (10-100), 
                            "defense": number (0-50), 
                            "speed": number (5-50) 
                            // æ ¹æ®æè¿°æ·»åŠ å…¶ä»–ç›¸å…³å±æ€§
                        },
                        "skills": [
                            { 
                                "name": "string (ä¸­æ–‡æŠ€èƒ½å)", 
                                "type": "active"|"passive", 
                                "damage": number (0-100, è¢«åŠ¨/å¢ç›ŠæŠ€èƒ½ä¸º0), 
                                "cost": number (0-50), 
                                "costType": "mp"|"stamina"|"energy"|"none", 
                                "target": "single"|"aoe"|"self"|"all_enemies", 
                                "statusEffects": ["string (å¦‚ 'burn', 'freeze', 'poison', 'stun', 'disarm', 'bind')"],
                                "description": "string (ä¸­æ–‡æè¿°)" 
                            }
                        ],
                        "items": [
                            { "name": "string (ä¸­æ–‡ç‰©å“å)", "type": "consumable"|"equipment"|"material", "effect": { "hp": number, "mp": number }, "count": number, "description": "string" }
                        ],
                        "story": "string (ä¸°å¯Œçš„ä¸­æ–‡èƒŒæ™¯æ•…äº‹)"
                    }
                    
                    æŒ‡å¯¼æ–¹é’ˆï¼š
                    - æ ¹æ®èŒä¸šå¤æ‚ç¨‹åº¦åˆ›å»º 3 åˆ° 10 ä¸ªæŠ€èƒ½ã€‚
                    - åŒ…å«å¤šæ ·åŒ–çš„æœºåˆ¶ï¼šä¼¤å®³ã€æ²»ç–—ã€å¢ç›Š (Buffs)ã€å‡ç›Š (Debuffs)ã€‚
                    - å¦‚æœåˆé€‚ï¼ŒåŒ…å« 1-2 ä¸ªè¢«åŠ¨æŠ€èƒ½ã€‚
                    - ç»™è§’è‰² 3-5 ä¸ªåˆå§‹ç‰©å“ï¼ˆä¾‹å¦‚ï¼šç”Ÿå‘½è¯æ°´ã€å£ç²®ã€åœ°å›¾ã€æ­¦å™¨ï¼‰ã€‚
                    - ç¡®ä¿èµ„æºæ¶ˆè€—ä¸æä¾›çš„å±æ€§ç›¸åŒ¹é…ã€‚`
                },
                {
                    role: "user",
                    content: `ä¸–ç•Œè®¾å®š: ${worldview}\nè§’è‰²æè¿°: ${description}`
                }
            ];
        };

        // Prompt for Adventure Phase (Exploration)
        const getAdventurePrompt = (player, history, action) => {
             const lastLog = history.length > 0 ? history[history.length - 1].text : "";
             return [
                {
                    role: "system",
                    content: `ä½ æ˜¯ä¸€ä½ RPG æ¸¸æˆä¸»æŒäºº (DM)ã€‚ç©å®¶æ­£åœ¨æ¢ç´¢ä¸–ç•Œã€‚
                    å½“å‰ç©å®¶: ${player.name} (${player.class}).
                    å±æ€§: ${JSON.stringify(player.stats)}.
                    æŠ€èƒ½: ${JSON.stringify(player.skills)}.
                    ç‰©å“æ : ${JSON.stringify(player.items || [])}.
                    
                    ç”¨æˆ·æ‰§è¡Œäº†ä¸€ä¸ªè¡ŒåŠ¨ã€‚è¯·ä»¥ä¸°å¯Œã€å¼•äººå…¥èƒœçš„å°è¯´é£æ ¼æè¿°ç»“æœã€‚
                    
                    é£æ ¼æŒ‡å—ï¼š
                    - ä½¿ç”¨æ„Ÿå®˜ç»†èŠ‚ï¼ˆç©å®¶çœ‹åˆ°äº†ä»€ä¹ˆã€å¬åˆ°äº†ä»€ä¹ˆã€é—»åˆ°äº†ä»€ä¹ˆï¼Ÿï¼‰ã€‚
                    - æè¿°è¦è¯¦å°½è€Œä¸æ˜¯ç®€ç•¥ï¼ˆ3-5æ®µæ¯”è¾ƒåˆé€‚ï¼‰ã€‚
                    - ä¸ºç©å®¶æ¥ä¸‹æ¥çš„è¡ŒåŠ¨æä¾›æ¸…æ™°çš„å¼•å¯¼æˆ–â€œé’©å­â€ã€‚
                    
                    å¦‚æœç”¨æˆ·è¡ŒåŠ¨æš—ç¤ºäº†å­¦ä¹ ã€å‡çº§æˆ–é—å¿˜æŠ€èƒ½ï¼ˆä¾‹å¦‚â€œæˆ‘ç ”è¯»äº†é‚£æœ¬å¤ç±â€ã€â€œæˆ‘ç»ƒä¹ å‰‘æœ¯â€ï¼‰ï¼Œä½ å¯ä»¥ä¿®æ”¹ä»–ä»¬çš„æŠ€èƒ½ã€‚

                    é‡è¦æç¤ºï¼šå™è¿°å¿…é¡»ä½¿ç”¨ç®€ä½“ä¸­æ–‡ã€‚
                    
                    ä»…è¿”å›ç¬¦åˆæ­¤ç»“æ„çš„æœ‰æ•ˆ JSONã€‚
                    **å…³é”®è§„åˆ™ï¼šå­—æ®µä»…åœ¨æœ‰å†…å®¹æ—¶è¿”å›ã€‚å¦‚æœåˆ—è¡¨ä¸ºç©ºæˆ–æ²¡æœ‰å˜åŒ–ï¼Œè¯·å®Œå…¨çœç•¥è¯¥å­—æ®µï¼ˆé™¤äº† narrativeï¼‰ã€‚**

                    {
                        "narrative": "string (å¿…é¡»åŒ…å«ã€‚é•¿ç¯‡æè¿°æ€§å™è¿°)",
                        "statChanges": { "hp": number, ... }, // å¯é€‰ï¼šä»…åœ¨å±æ€§å˜åŒ–æ—¶åŒ…å«
                        "newItems": [ // å¯é€‰ï¼šä»…åœ¨è·å¾—ç‰©å“æ—¶åŒ…å«
                            { "name": "string", "type": "consumable"|"equipment"|"material", "effect": { "hp": number, "mp": number }, "count": number, "description": "string" }
                        ],
                        "removedItems": ["string"], // å¯é€‰
                        "newSkills": [ // å¯é€‰ï¼šä»…åœ¨ä¹ å¾—æ–°æŠ€èƒ½æ—¶åŒ…å«
                             { 
                                "name": "string", 
                                "type": "active"|"passive", 
                                "damage": number, 
                                "cost": number, 
                                "costType": "mp"|"stamina", 
                                "target": "single"|"aoe"|"self", 
                                "statusEffects": ["string"],
                                "description": "string" 
                            }
                        ],
                        "removedSkills": ["string"], // å¯é€‰
                        "updatedSkills": [ ... ], // å¯é€‰
                        "newEnemies": [ // å¯é€‰ï¼šä»…åœ¨æˆ˜æ–—è§¦å‘æ—¶åŒ…å«
                            { 
                                "name": "string", 
                                "stats": { "hp": number, "maxHp": number, "attack": number, "defense": number, "speed": number },
                                "skills": ["string"],
                                "traits": [ { "name": "string", "effect": "string", "description": "string" } ],
                                "description": "string"
                            }
                        ]
                    }
                    `
                },
                {
                    role: "user",
                    content: `å‰æƒ…æè¦: ${lastLog}\nç©å®¶è¡ŒåŠ¨: ${action}`
                }
            ];
        };

        // Prompt for Combat Phase (Multi-Enemy)
        const getCombatPrompt = (player, enemies, action, targetIndex, history, showNarrative) => {
            const lastLog = history.length > 0 ? history[history.length - 1].text : "";
            
            const enemyState = enemies.map((e, i) => {
                const traits = e.traits ? e.traits.map(t => t.name).join(",") : "";
                return `[${i}] ${e.name} (HP ${e.stats.hp}/${e.stats.maxHp}, ç‰¹æ€§: ${traits})`;
            }).join("\n");
            
            const playerSkills = player.skills.map(s => `${s.name} (${s.type}, ${s.cost}${s.costType})`).join(", ");
            const playerBuffs = player.buffs ? JSON.stringify(player.buffs) : "æ— ";

            return [
                {
                    role: "system",
                    content: `ä½ æ˜¯ä¸€ä½ RPG æˆ˜æ–—è§£è¯´å‘˜ã€‚
                    ç©å®¶: ${player.name} (HP ${player.stats.hp}/${player.stats.maxHp}, MP ${player.stats.mp}/${player.stats.maxMp}).
                    ç©å®¶æŠ€èƒ½: ${playerSkills}
                    ç©å®¶ Buffs: ${playerBuffs}
                    
                    æ•Œäºº:
                    ${enemyState}
                    
                    è¡ŒåŠ¨: ${JSON.stringify(action)}
                    ç›®æ ‡ç´¢å¼•: ${targetIndex}
                    
                    ä»»åŠ¡:
                    1. è®¡ç®—ç©å®¶é€ æˆçš„ä¼¤å®³ï¼ˆè€ƒè™‘ Buffsã€æ•Œäººç‰¹æ€§å¦‚é˜²å¾¡/åä¼¤ï¼‰ã€‚
                    2. è®¡ç®—æ•Œäººå›åˆï¼ˆæ•Œäººæ”»å‡»ç©å®¶ï¼Œè€ƒè™‘ä»–ä»¬çš„æŠ€èƒ½/ç‰¹æ€§ï¼‰ã€‚
                    3. ç®¡ç† Buffs/Debuffsï¼ˆæŒç»­æ—¶é—´å‡å°‘ï¼Œæœ‰äº›å¯èƒ½è¿‡æœŸï¼‰ã€‚
                    
                    ${showNarrative ? "æä¾›ç”ŸåŠ¨çš„æˆ˜æ–—æè¿°ã€‚" : "æä¾›éå¸¸ç®€çŸ­çš„æ€»ç»“ã€‚"}
                    
                    ä»…è¿”å›ç¬¦åˆæ­¤ç»“æ„çš„æœ‰æ•ˆ JSONã€‚
                    **å…³é”®è§„åˆ™ï¼šå­—æ®µä»…åœ¨æœ‰å†…å®¹æ—¶è¿”å›ã€‚å¦‚æœæ²¡æœ‰å˜åŒ–æˆ–åˆ—è¡¨ä¸ºç©ºï¼Œè¯·å®Œå…¨çœç•¥è¯¥å­—æ®µï¼ˆnarrative é™¤å¤–ï¼‰ã€‚**

                    {
                        "narrative": "string (å¿…é¡»åŒ…å«)",
                        "playerStatChanges": { "hp": number, ... }, // å¯é€‰ï¼šä»…åœ¨å˜åŒ–æ—¶åŒ…å«
                        "enemiesUpdates": [ // å¯é€‰ï¼šä»…åœ¨æ•ŒäººçŠ¶æ€å˜åŒ–æ—¶åŒ…å«
                            { 
                                "index": number, 
                                "damageTaken": number, 
                                "hpChange": number, 
                                "statusAdded": "string",
                                "statusRemoved": "string"
                            }
                        ],
                        "playerBuffsAdded": [ // å¯é€‰
                             { "name": "string", "effect": "string", "duration": number, "description": "string", "type": "buff"|"debuff" }
                        ],
                        "playerBuffsRemoved": ["string"], // å¯é€‰
                        "enemyBuffsAdded": [ // å¯é€‰
                             { "enemyIndex": number, "buff": { "name": "string", "description": "string", "duration": number } }
                        ]
                    }
                    `
                },
                {
                    role: "user",
                    content: `æ‰§è¡Œæˆ˜æ–—å›åˆã€‚`
                }
            ];
        };

        // --- Helper Functions ---
        
        const rollDice = (expression) => {
            try {
                // Simple parser for XdY+Z format
                const regex = /^(\d+)d(\d+)(?:\+([-]?\d+))?$/i;
                const match = expression.trim().match(regex);
                
                if (!match) {
                    // Try parsing just a number
                    const num = parseInt(expression);
                    if (!isNaN(num)) return { total: num, details: `${num}`, expression };
                    throw new Error("æ— æ•ˆçš„è¡¨è¾¾å¼ã€‚æ ¼å¼ç¤ºä¾‹: 2d6, 1d20+5");
                }

                const count = parseInt(match[1]);
                const sides = parseInt(match[2]);
                const modifier = match[3] ? parseInt(match[3]) : 0;

                if (count > 100) throw new Error("éª°å­æ•°é‡è¿‡å¤š");
                if (sides > 1000) throw new Error("éª°å­é¢æ•°è¿‡å¤š");

                let total = 0;
                const rolls = [];
                for (let i = 0; i < count; i++) {
                    const roll = Math.floor(Math.random() * sides) + 1;
                    rolls.push(roll);
                    total += roll;
                }
                total += modifier;

                const details = `[${rolls.join(",")}]${modifier !== 0 ? (modifier > 0 ? `+${modifier}` : modifier) : ""} = ${total}`;
                return { total, details, expression };
            } catch (e) {
                return { error: e.message };
            }
        };

        // --- Components ---

        function ConfigScreen({ onConnect }) {
            const [config, setConfig] = useState(() => {
                const saved = localStorage.getItem("ai_rpg_config");
                return saved ? JSON.parse(saved) : DEFAULT_CONFIG;
            });
            
            const [customModel, setCustomModel] = useState("");

            useEffect(() => {
                localStorage.setItem("ai_rpg_config", JSON.stringify(config));
            }, [config]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (config.apiKey.trim().length > 0) {
                    const finalConfig = { ...config };
                    if (config.model === 'custom') {
                        finalConfig.model = customModel;
                    }
                    onConnect(finalConfig);
                }
            };

            const handleProviderChange = (newProvider) => {
                let newBaseUrl = "";
                if (newProvider === PROVIDERS.GOOGLE) newBaseUrl = "https://generativelanguage.googleapis.com";
                else if (newProvider === PROVIDERS.DEEPSEEK) newBaseUrl = "https://api.deepseek.com";
                else if (newProvider === PROVIDERS.ANTHROPIC) newBaseUrl = "https://api.anthropic.com";
                else newBaseUrl = "https://api.openai.com/v1";

                setConfig(prev => ({
                    ...prev,
                    provider: newProvider,
                    // Default to first model of that provider
                    model: AVAILABLE_MODELS.find(m => m.provider === newProvider)?.id || 'custom',
                    baseUrl: newBaseUrl
                }));
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-900 text-gray-200">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-lg max-w-md w-full border border-gray-700 space-y-6">
                        <div>
                            <h1 className="text-2xl font-bold text-center text-purple-400">æ¸¸æˆè®¾ç½® (Game Config)</h1>
                            <p className="text-center text-xs text-gray-500 mt-1">é€‰æ‹©ä½ çš„ AI å¼•æ“</p>
                        </div>

                        <form onSubmit={handleSubmit} className="space-y-4">
                            {/* Provider Selection */}
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-400">AI æä¾›å•† (Provider)</label>
                                <div className="flex gap-2 flex-wrap">
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.GOOGLE)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.GOOGLE ? 'bg-purple-600 border-purple-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        Google
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.DEEPSEEK)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.DEEPSEEK ? 'bg-blue-600 border-blue-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        DeepSeek
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.ANTHROPIC)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.ANTHROPIC ? 'bg-orange-600 border-orange-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        Claude
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.OPENAI)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.OPENAI ? 'bg-green-600 border-green-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        OpenAI
                                    </button>
                                </div>
                            </div>

                            {/* Model Selection */}
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-400">æ¨¡å‹ (Model)</label>
                                <select
                                    value={config.model}
                                    onChange={(e) => setConfig({...config, model: e.target.value})}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                >
                                    {AVAILABLE_MODELS.filter(m => m.provider === config.provider).map(m => (
                                        <option key={m.id} value={m.id}>{m.name}</option>
                                    ))}
                                    {config.provider === PROVIDERS.OPENAI && <option value="custom">è‡ªå®šä¹‰ / å…¶ä»–...</option>}
                                </select>
                            </div>

                            {/* Custom Model Input (Only if custom selected) */}
                            {config.model === 'custom' && (
                                <div>
                                    <label className="block text-sm font-medium mb-1 text-gray-400">è‡ªå®šä¹‰æ¨¡å‹ ID</label>
                                    <input
                                        type="text"
                                        value={customModel}
                                        onChange={(e) => setCustomModel(e.target.value)}
                                        className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                        placeholder="ä¾‹å¦‚ï¼šclaude-3-opus..."
                                        required
                                    />
                                </div>
                            )}

                            {/* API Key */}
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-400">API å¯†é’¥ (Key)</label>
                                <input 
                                    type="password" 
                                    value={config.apiKey}
                                    onChange={(e) => setConfig({...config, apiKey: e.target.value})}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                    placeholder={
                                        config.provider === PROVIDERS.GOOGLE ? "AIza..." : 
                                        config.provider === PROVIDERS.ANTHROPIC ? "sk-ant-..." :
                                        "sk-..."
                                    }
                                    required
                                />
                                {config.provider === PROVIDERS.ANTHROPIC && (
                                    <p className="text-[10px] text-orange-400 mt-1">
                                        æ³¨æ„: ç›´æ¥åœ¨æµè§ˆå™¨ä½¿ç”¨ Anthropic Key å¯èƒ½ä¼šå› ä¸º CORS å¤±è´¥ã€‚å»ºè®®ä½¿ç”¨è½¬å‘ä»£ç†åœ°å€ (Base URL)ã€‚
                                    </p>
                                )}
                            </div>

                            <button 
                                type="submit" 
                                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-200 mt-4"
                            >
                                è¿æ¥å¹¶å¼€å§‹ (Connect)
                            </button>
                        </form>
                    </div>
                </div>
            );
        }

        function CharacterCreation({ onCharacterCreated, config }) {
            const [worldview, setWorldview] = useState("èµ›åšæœ‹å…‹");
            const [description, setDescription] = useState("ä¸€ä¸ªæ‹¥æœ‰æœºæ¢°è‡‚çš„æµæµªé»‘å®¢ã€‚");
            const [loading, setLoading] = useState(false);

            const handleSubmit = async (e) => {
                e.preventDefault();
                setLoading(true);
                try {
                    const messages = getCharGenPrompt(worldview, description);
                    const charData = await callAI(config, messages);
                    onCharacterCreated(charData);
                } catch (error) {
                    alert("ç”Ÿæˆè§’è‰²å¤±è´¥: " + error.message);
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-4">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-lg max-w-md w-full border border-gray-700">
                        <h1 className="text-3xl font-bold mb-6 text-center text-purple-400">AI RPG ç”Ÿæˆå™¨</h1>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-300">ä¸–ç•Œè§‚è®¾å®š</label>
                                <input 
                                    type="text" 
                                    value={worldview}
                                    onChange={(e) => setWorldview(e.target.value)}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                    placeholder="ä¾‹å¦‚ï¼šèµ›åšæœ‹å…‹ 2077ï¼Œé«˜é­”å¥‡å¹»..."
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-300">è§’è‰²æè¿°</label>
                                <textarea 
                                    value={description}
                                    onChange={(e) => setDescription(e.target.value)}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white h-32"
                                    placeholder="æè¿°ä½ çš„è‹±é›„..."
                                />
                            </div>
                            <button 
                                type="submit" 
                                disabled={loading}
                                className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition duration-200 disabled:opacity-50 flex justify-center items-center gap-2"
                            >
                                {loading ? "æ­£åœ¨æ„æ€..." : "å¼€å§‹å†’é™©"}
                            </button>
                        </form>
                        <div className="text-center mt-4 text-xs text-gray-500">
                            è¿è¡Œæ¨¡å‹ï¼š{config.model}
                        </div>
                    </div>
                </div>
            );
        }

        function GameInterface({ character, config }) {
            const [player, setPlayer] = useState(character);
            // Phase: 'adventure' (Exploration) or 'combat'
            const [phase, setPhase] = useState('adventure'); 
            
            const [enemies, setEnemies] = useState([]);
            const [selectedTargetIndex, setSelectedTargetIndex] = useState(0);
            
            const [logs, setLogs] = useState([
                { text: character.story, type: 'narrative' },
                { text: "å†’é™©å¼€å§‹äº†ã€‚ä½ å¯ä»¥è¾“å…¥è¡ŒåŠ¨æ¥æ¢ç´¢è¿™ä¸ªä¸–ç•Œã€‚", type: 'narrative' }
            ]);
            
            const [inputAction, setInputAction] = useState("");
            const [processing, setProcessing] = useState(false);
            const [showDice, setShowDice] = useState(false);
            const [diceExpression, setDiceExpression] = useState("1d20");
            const [showInventory, setShowInventory] = useState(false);
            const [showNarrative, setShowNarrative] = useState(true); // New Toggle

            const logContainerRef = useRef(null);
            const fileInputRef = useRef(null);

            // --- Export / Import Handlers ---
            const handleExport = () => {
                const gameState = {
                    player,
                    phase,
                    enemies,
                    selectedTargetIndex,
                    logs,
                    timestamp: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(gameState, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai-rpg-save-${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const handleImportClick = () => {
                fileInputRef.current.click();
            };

            const handleImportFile = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const gameState = JSON.parse(e.target.result);
                        // Basic validation
                        if (gameState.player && Array.isArray(gameState.logs)) {
                            setPlayer(gameState.player);
                            setPhase(gameState.phase || 'adventure');
                            setEnemies(gameState.enemies || []);
                            if (gameState.selectedTargetIndex !== undefined) setSelectedTargetIndex(gameState.selectedTargetIndex);
                            setLogs(gameState.logs);
                            // Add a system log to indicate success (without adding to history for export potentially, but useful for user)
                            // We actually replace logs, so we should probably append this success message to the loaded logs 
                            // OR just rely on the state update. But appending is nicer.
                            // However, since logs is state, we can't easily append *after* setLogs in the same tick reliably for display if we just replaced it.
                            // But we can append to the array before setting.
                            const newLogs = [...gameState.logs, { text: "âœ… å­˜æ¡£/è®°å½•å·²æˆåŠŸå¯¼å…¥ï¼", type: "success" }];
                            setLogs(newLogs);
                        } else {
                            throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘å¿…è¦æ•°æ®");
                        }
                    } catch (err) {
                        alert("å¯¼å…¥å¤±è´¥: " + err.message);
                    }
                };
                reader.readAsText(file);
                event.target.value = ''; // Reset
            };

            useEffect(() => {
                if (logContainerRef.current) {
                    logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
                }
            }, [logs]);

            const addLog = (text, type = 'neutral') => {
                setLogs(prev => [...prev, { text, type }]);
            };

            const handleRollDice = (e) => {
                e.preventDefault(); // Prevent form submission if inside a form
                const result = rollDice(diceExpression);
                if (result.error) {
                    addLog(`ğŸ² æ·éª°é”™è¯¯: ${result.error}`, 'danger');
                } else {
                    const rollText = `(ğŸ² ${result.expression}: ${result.details})`;
                    setInputAction(prev => (prev ? prev + " " + rollText : rollText));
                    addLog(`ğŸ² æ·éª°æ£€å®š: ${result.expression} => ${result.details}`, 'action');
                    setShowDice(false);
                }
            };

            const handleUseItem = (itemIndex) => {
                const item = player.items[itemIndex];
                if (!item) return;

                // Apply effects if consumable
                if (item.type === 'consumable' && item.effect) {
                    setPlayer(prev => {
                        const newStats = { ...prev.stats };
                        Object.entries(item.effect).forEach(([key, value]) => {
                            if (typeof newStats[key] !== 'undefined') {
                                const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                                newStats[key] = newStats[key] + value;
                                if (typeof newStats[maxKey] !== 'undefined') {
                                    newStats[key] = Math.min(newStats[key], newStats[maxKey]);
                                }
                            }
                        });
                        
                        // Decrease count or remove
                        const newItems = [...prev.items];
                        newItems[itemIndex].count--;
                        if (newItems[itemIndex].count <= 0) {
                            newItems.splice(itemIndex, 1);
                        }
                        
                        return { ...prev, stats: newStats, items: newItems };
                    });
                    addLog(`ä½¿ç”¨äº† ${item.name}`, 'success');
                    
                    // In combat, using an item might take a turn? 
                    // For now, let's assume it's a free action or part of the narrative action 
                    // But if in combat, we might want to trigger a turn update.
                    // Let's keep it simple: Using item from UI is "instant" but maybe we should tell AI?
                    // Ideally, using item should be an action sent to AI.
                    // But for now, let's just update stats locally.
                } else {
                    addLog(`${item.name} æ— æ³•ç›´æ¥ä½¿ç”¨`, 'neutral');
                }
            };

            // --- Adventure Phase Handler ---
            const handleAdventureAction = async () => {
                if (processing || !inputAction.trim()) return;
                const action = inputAction.trim();
                setInputAction("");
                setProcessing(true);
                addLog(`> ${action}`, 'action');

                try {
                    const messages = getAdventurePrompt(player, logs, action);
                    const result = await callAI(config, messages);
                    
                    addLog(result.narrative, 'narrative');

                    // Handle Stat Changes (Healing/Items)
                    setPlayer(prev => {
                        let newStats = { ...prev.stats };
                        let newItems = prev.items ? [...prev.items] : [];

                        if (result.statChanges) {
                            Object.entries(result.statChanges).forEach(([key, value]) => {
                                if (typeof newStats[key] !== 'undefined') {
                                    newStats[key] = newStats[key] + value;
                                    const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                                    if (typeof newStats[maxKey] !== 'undefined') {
                                        newStats[key] = Math.min(newStats[key], newStats[maxKey]);
                                    }
                                    newStats[key] = Math.max(0, newStats[key]);
                                }
                            });
                        }

                        // Handle New Items
                        if (result.newItems) {
                            result.newItems.forEach(newItem => {
                                const existingItemIndex = newItems.findIndex(i => i.name === newItem.name);
                                if (existingItemIndex >= 0) {
                                    newItems[existingItemIndex].count += newItem.count;
                                } else {
                                    newItems.push(newItem);
                                }
                                addLog(`è·å¾—ç‰©å“: ${newItem.name} x${newItem.count}`, 'success');
                            });
                        }

                        // Handle Removed Items
                        if (result.removedItems) {
                            result.removedItems.forEach(remName => {
                                const idx = newItems.findIndex(i => i.name === remName);
                                if (idx >= 0) {
                                    newItems[idx].count--;
                                    if (newItems[idx].count <= 0) newItems.splice(idx, 1);
                                }
                            });
                        }

                        // Handle New/Removed/Updated Skills
                        let newSkillsList = prev.skills ? [...prev.skills] : [];
                        
                        if (result.newSkills) {
                            result.newSkills.forEach(skill => {
                                if (!newSkillsList.find(s => s.name === skill.name)) {
                                    newSkillsList.push(skill);
                                    addLog(`ğŸ’¡ ä¹ å¾—æ–°æŠ€èƒ½: ${skill.name}`, 'success');
                                }
                            });
                        }

                        if (result.updatedSkills) {
                             result.updatedSkills.forEach(skill => {
                                const idx = newSkillsList.findIndex(s => s.name === skill.name);
                                if (idx >= 0) {
                                    newSkillsList[idx] = skill;
                                    addLog(`ğŸ†™ æŠ€èƒ½å‡çº§: ${skill.name}`, 'success');
                                }
                            });
                        }

                        if (result.removedSkills) {
                            result.removedSkills.forEach(name => {
                                const idx = newSkillsList.findIndex(s => s.name === name);
                                if (idx >= 0) {
                                    newSkillsList.splice(idx, 1);
                                    addLog(`âŒ é—å¿˜æŠ€èƒ½: ${name}`, 'neutral');
                                }
                            });
                        }

                        return { ...prev, stats: newStats, items: newItems, skills: newSkillsList };
                    });

                    if (result.newEnemies && result.newEnemies.length > 0) {
                        setEnemies(result.newEnemies);
                        setPhase('combat');
                        setSelectedTargetIndex(0);
                        addLog(`âš ï¸ é­é‡æ•Œè¢­ï¼å‡ºç° ${result.newEnemies.length} ä¸ªæ•Œäººï¼`, 'danger');
                    }

                } catch (error) {
                    addLog(`é”™è¯¯: ${error.message}`, 'danger');
                } finally {
                    setProcessing(false);
                }
            };

            // --- Combat Phase Handler ---
            const handleCombatAction = async (actionType, skill = null) => {
                if (processing || player.stats.hp <= 0) return;
                
                // Construct action object (Skill or Custom Text)
                let actionObj = {};
                let costDeduced = false;
                let tempPlayer = { ...player }; // Mutable copy for prompt generation

                if (skill) {
                    // 1. JS Logic: Check and Deduct Cost
                    if (skill.cost > 0) {
                        const costType = skill.costType ? skill.costType.toLowerCase() : 'mp';
                        let statKey = 'mp'; 
                        if (costType === 'stamina') statKey = 'stamina';
                        if (costType === 'energy') statKey = 'mp'; 

                        // Check if stat exists
                        if (player.stats[statKey] !== undefined) {
                            if (player.stats[statKey] < skill.cost) {
                                addLog(`âŒ ${statKey === 'mp' ? 'é­”æ³•å€¼' : 'ä½“åŠ›'}ä¸è¶³ (${player.stats[statKey]}/${skill.cost})ï¼Œæ— æ³•ä½¿ç”¨ ${skill.name}`, 'danger');
                                return;
                            }
                            // Deduct immediately for UI feedback
                            setPlayer(prev => ({
                                ...prev,
                                stats: {
                                    ...prev.stats,
                                    [statKey]: prev.stats[statKey] - skill.cost
                                }
                            }));
                            costDeduced = true;
                            // Update tempPlayer for AI context so it knows current resources
                            tempPlayer.stats = { ...player.stats, [statKey]: player.stats[statKey] - skill.cost };
                        }
                    }

                    actionObj = { 
                        name: skill.name, 
                        type: skill.type, 
                        damage: skill.damage, 
                        cost: skill.cost,
                        target: skill.target,
                        effects: skill.statusEffects || []
                    };
                } else {
                    if (!inputAction.trim()) return;
                    actionObj = { name: inputAction.trim(), type: 'custom' };
                    setInputAction("");
                }

                setProcessing(true);
                addLog(`> ${actionObj.name} (ç›®æ ‡: ${enemies[selectedTargetIndex]?.name || 'æ— '})`, 'action');

                try {
                    const messages = getCombatPrompt(tempPlayer, enemies, actionObj, selectedTargetIndex, logs, showNarrative);
                    const result = await callAI(config, messages);
                    
                    // Update State based on AI calculation
                    
                    // 1. Handle Enemy Updates
                    let newEnemies = [...enemies];
                    if (result.enemiesUpdates) {
                        result.enemiesUpdates.forEach(update => {
                            if (newEnemies[update.index]) {
                                const e = newEnemies[update.index];
                                
                                // Update HP
                                if (update.hpChange !== undefined) {
                                    e.stats.hp = Math.max(0, Math.min(e.stats.maxHp, e.stats.hp + update.hpChange));
                                } else if (update.damageTaken !== undefined) {
                                    e.stats.hp = Math.max(0, e.stats.hp - update.damageTaken);
                                }

                                // Handle Status/Buffs (Initialize if needed)
                                if (!e.buffs) e.buffs = [];
                                
                                if (update.statusAdded) {
                                    // Simple status string support for now, or expand to object
                                    if (!e.buffs.find(b => b.name === update.statusAdded)) {
                                        e.buffs.push({ name: update.statusAdded, duration: 3 }); // Default duration if not specified
                                    }
                                }
                                if (update.statusRemoved) {
                                    e.buffs = e.buffs.filter(b => b.name !== update.statusRemoved);
                                }
                            }
                        });
                    }
                    
                    // 2. Handle Enemy Buffs (Explicit Object)
                    if (result.enemyBuffsAdded) {
                        result.enemyBuffsAdded.forEach(item => {
                            if (newEnemies[item.enemyIndex]) {
                                if (!newEnemies[item.enemyIndex].buffs) newEnemies[item.enemyIndex].buffs = [];
                                newEnemies[item.enemyIndex].buffs.push(item.buff);
                            }
                        });
                    }

                    // 3. Handle Player Updates
                    let playerStatUpdates = {};
                    if (result.playerStatChanges) {
                        playerStatUpdates = result.playerStatChanges;
                    } else if (result.playerDamageTaken) {
                        playerStatUpdates.hp = -result.playerDamageTaken;
                    }

                    setPlayer(prev => {
                        const newStats = { ...prev.stats };
                        let newBuffs = prev.buffs ? [...prev.buffs] : [];

                        // Apply Stat Changes
                        Object.entries(playerStatUpdates).forEach(([key, value]) => {
                            if (typeof newStats[key] !== 'undefined') {
                                newStats[key] += value;
                                const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                                if (typeof newStats[maxKey] !== 'undefined') {
                                    newStats[key] = Math.min(newStats[key], newStats[maxKey]);
                                }
                                newStats[key] = Math.max(0, newStats[key]); // No negative stats
                            }
                        });

                        // Apply Buffs
                        if (result.playerBuffsAdded) {
                            result.playerBuffsAdded.forEach(buff => {
                                newBuffs.push(buff);
                                addLog(`ğŸ”¼ è·å¾—çŠ¶æ€: ${buff.name} (${buff.description})`, 'success');
                            });
                        }
                        if (result.playerBuffsRemoved) {
                            result.playerBuffsRemoved.forEach(name => {
                                newBuffs = newBuffs.filter(b => b.name !== name);
                                addLog(`ğŸ”½ çŠ¶æ€æ¶ˆå¤±: ${name}`, 'neutral');
                            });
                        }
                        
                        // Decrement Buff Duration (Optional: could be done by AI, but safe to do here too if AI doesn't return list)
                        // Actually, AI instruction says "Manage Buffs... duration decreases". 
                        // So we expect AI to tell us if something is removed. 
                        // If AI doesn't send "updatedBuffs", we might need to decrement locally?
                        // Let's assume AI handles removal via 'playerBuffsRemoved'. 
                        // To be safe, maybe we should update duration if AI sends full list?
                        // For now, trust AI to send 'playerBuffsRemoved'.
                        
                        return { ...prev, stats: newStats, buffs: newBuffs };
                    });

                    if (showNarrative && result.narrative) {
                        addLog(result.narrative, 'combat');
                    } else if (!showNarrative && result.narrative) {
                         // Maybe log a short summary or nothing?
                         // addLog("(Combat occurred...)", 'action');
                    }

                    // 4. Check for Deaths
                    const aliveEnemies = newEnemies.filter(e => e.stats.hp > 0);
                    setEnemies(aliveEnemies);
                    
                    if (selectedTargetIndex >= aliveEnemies.length) {
                        setSelectedTargetIndex(Math.max(0, aliveEnemies.length - 1));
                    }

                    // Check Player Death (Estimate based on current state + updates)
                    // Since setPlayer is async, we use the values we calculated.
                    let currentHp = player.stats.hp;
                    if (playerStatUpdates.hp) currentHp += playerStatUpdates.hp;
                    
                    if (aliveEnemies.length === 0) {
                        addLog("ğŸ† æˆ˜æ–—èƒœåˆ©ï¼", 'success');
                        // Clean up temporary combat buffs
                         setPlayer(prev => ({
                            ...prev,
                            buffs: (prev.buffs || []).filter(b => b.duration === -1 || b.permanent) // Remove non-permanent
                        }));
                        setPhase('adventure');
                    } else if (currentHp <= 0) {
                        addLog("ğŸ’€ ä½ è¢«æ‰“è´¥äº†...", 'danger');
                    }

                } catch (error) {
                    addLog(`é”™è¯¯: ${error.message}`, 'danger');
                } finally {
                    setProcessing(false);
                }
            };

            // Helper to render dynamic status bars
            const renderStats = () => {
                const statKeys = Object.keys(player.stats);
                // Find "bar" stats: keys that have a corresponding "maxKey" (e.g. hp/maxHp, mp/maxMp)
                const barStats = [];
                const otherStats = [];

                statKeys.forEach(key => {
                    if (key.startsWith('max')) return; // Skip max keys
                    const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                    if (player.stats[maxKey] !== undefined) {
                        barStats.push({ key, maxKey, label: key.toUpperCase() });
                    } else {
                        otherStats.push({ key, label: key.toUpperCase() });
                    }
                });

                return (
                    <>
                        {/* Bars */}
                        {barStats.map(stat => (
                            <div key={stat.key} className="mb-2">
                                <div className="flex justify-between text-xs uppercase text-gray-400 mb-1">
                                    <span>{stat.key}</span>
                                    <span>{Math.floor(player.stats[stat.key])}/{player.stats[stat.maxKey]}</span>
                                </div>
                                <div className="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                                    <div 
                                        className={`h-full transition-all duration-500 ${
                                            stat.key === 'hp' ? 'bg-green-500' : 
                                            stat.key === 'mp' ? 'bg-blue-500' : 
                                            stat.key === 'stamina' ? 'bg-yellow-500' : 'bg-purple-500'
                                        }`} 
                                        style={{ width: `${Math.min(100, Math.max(0, (player.stats[stat.key] / player.stats[stat.maxKey]) * 100))}%` }}
                                    ></div>
                                </div>
                            </div>
                        ))}
                        
                        {/* Grid for other stats */}
                        <div className="grid grid-cols-3 gap-2 mt-3 text-sm text-gray-400">
                            {otherStats.map(stat => (
                                <div key={stat.key} className="flex flex-col items-center bg-gray-700/30 rounded p-1">
                                    <span className="text-xs text-gray-500 uppercase">{stat.key}</span>
                                    <span className="font-bold text-gray-200">{player.stats[stat.key]}</span>
                                </div>
                            ))}
                        </div>
                    </>
                );
            };

            return (
                <div className="flex flex-col h-screen max-w-7xl mx-auto p-2 md:p-4">
                    {/* Top Bar with Save/Load */}
                    <div className="flex justify-end gap-2 mb-2 shrink-0">
                        <input 
                            type="file" 
                            ref={fileInputRef}
                            onChange={handleImportFile}
                            style={{ display: 'none' }}
                            accept=".json"
                        />
                        <button 
                            onClick={handleImportClick}
                            className="px-3 py-1 text-xs md:text-sm bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 flex items-center gap-1 transition-colors"
                            title="å¯¼å…¥ä¹‹å‰çš„æ¸¸æˆè®°å½•"
                        >
                            ğŸ“‚ å¯¼å…¥è®°å½•
                        </button>
                        <button 
                            onClick={handleExport}
                            className="px-3 py-1 text-xs md:text-sm bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 flex items-center gap-1 transition-colors"
                            title="ä¿å­˜å½“å‰æ¸¸æˆè®°å½•åˆ°æœ¬åœ°"
                        >
                            ğŸ’¾ å¯¼å‡ºè®°å½•
                        </button>
                    </div>

                    {/* Main Game Layout */}
                    <div className="flex-1 flex flex-col lg:flex-row gap-4 overflow-hidden">
                        
                        {/* LEFT PANEL: Player Stats */}
                        <div className="lg:w-72 shrink-0 flex flex-col gap-4 overflow-y-auto lg:overflow-y-visible">
                            <div className="bg-gray-800 p-4 rounded border border-gray-600 relative">
                                <div className="flex justify-between items-center mb-3">
                                    <h2 className="text-xl font-bold text-purple-400">{player.name}</h2>
                                    <div className="flex gap-2">
                                        <button 
                                            onClick={() => setShowInventory(!showInventory)}
                                            className="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded text-gray-300 flex items-center gap-1"
                                        >
                                            ğŸ’ ç‰©å“ ({player.items ? player.items.length : 0})
                                        </button>
                                        <span className="text-xs bg-gray-700 px-2 py-1 rounded text-gray-300">{player.class}</span>
                                    </div>
                                </div>
                                
                                {renderStats()}

                                {/* Buffs Section */}
                                {player.buffs && player.buffs.length > 0 && (
                                    <div className="mt-4">
                                        <h3 className="text-xs font-bold text-purple-400 uppercase mb-2">å½“å‰çŠ¶æ€ (Buffs)</h3>
                                        <div className="flex flex-wrap gap-2">
                                            {player.buffs.map((buff, i) => (
                                                <div key={i} className="text-xs bg-blue-900/50 border border-blue-500 px-2 py-1 rounded text-blue-200 cursor-help" title={`${buff.description || buff.effect} (å‰©ä½™: ${buff.duration} å›åˆ)`}>
                                                    {buff.name}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {/* Inventory Overlay - Adjusted for sidebar */}
                                {showInventory && (
                                    <div className="absolute top-12 left-0 lg:left-full lg:top-0 lg:ml-2 w-64 bg-gray-900 border border-gray-500 rounded shadow-xl z-50 max-h-80 overflow-y-auto">
                                        <div className="p-2 border-b border-gray-700 flex justify-between items-center bg-gray-800">
                                            <span className="text-sm font-bold text-gray-200">èƒŒåŒ…</span>
                                            <button onClick={() => setShowInventory(false)} className="text-gray-500 hover:text-white">Ã—</button>
                                        </div>
                                        <div className="p-2 space-y-2">
                                            {player.items && player.items.length > 0 ? (
                                                player.items.map((item, idx) => (
                                                    <div key={idx} className="bg-gray-800 p-2 rounded border border-gray-700 text-sm">
                                                        <div className="flex justify-between">
                                                            <span className="font-bold text-purple-300">{item.name}</span>
                                                            <span className="text-gray-400">x{item.count}</span>
                                                        </div>
                                                        <p className="text-xs text-gray-500 mb-1">{item.description}</p>
                                                        {item.type === 'consumable' && (
                                                            <button 
                                                                onClick={() => handleUseItem(idx)}
                                                                className="w-full bg-green-800 hover:bg-green-700 text-green-100 text-xs py-1 rounded"
                                                            >
                                                                ä½¿ç”¨
                                                            </button>
                                                        )}
                                                    </div>
                                                ))
                                            ) : (
                                                <div className="text-center text-gray-500 py-4 text-xs">èƒŒåŒ…æ˜¯ç©ºçš„</div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* CENTER PANEL: Main Game Area (Logs + Input) */}
                        <div className="flex-1 flex flex-col gap-4 overflow-hidden min-w-0 order-last lg:order-none">
                            {/* Log/Narrative Area */}
                            <div 
                                ref={logContainerRef}
                                className="flex-1 bg-gray-900 p-4 rounded border border-gray-700 overflow-y-auto space-y-2 font-mono text-sm md:text-base shadow-inner relative"
                            >
                                {/* Dice Overlay */}
                                {showDice && (
                                    <div className="absolute bottom-4 right-4 bg-gray-800 p-3 rounded border border-purple-500 shadow-xl z-20 flex flex-col gap-2 animate-in fade-in slide-in-from-bottom-2">
                                        <span className="text-xs text-purple-300 font-bold">æ·éª°å­ (Dice Roller)</span>
                                        <div className="flex gap-2">
                                            <input 
                                                type="text" 
                                                value={diceExpression}
                                                onChange={(e) => setDiceExpression(e.target.value)}
                                                className="w-24 p-1 text-sm rounded bg-gray-700 border border-gray-600 text-white"
                                                placeholder="1d20"
                                            />
                                            <button 
                                                onClick={handleRollDice}
                                                className="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded text-sm font-bold"
                                            >
                                                Roll
                                            </button>
                                        </div>
                                        <div className="flex gap-1 justify-between">
                                            {["1d20", "2d6", "1d100"].map(exp => (
                                                <button 
                                                    key={exp}
                                                    onClick={() => setDiceExpression(exp)}
                                                    className="text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 px-2 py-0.5 rounded"
                                                >
                                                    {exp}
                                                </button>
                                            ))}
                                        </div>
                                        <button 
                                            onClick={() => setShowDice(false)}
                                            className="text-xs text-gray-500 hover:text-gray-300 self-end mt-1"
                                        >
                                            å…³é—­
                                        </button>
                                    </div>
                                )}

                                {logs.map((log, i) => (
                                    <div key={i} className={`p-2 rounded leading-relaxed ${
                                        log.type === 'narrative' ? 'bg-gray-800 text-yellow-100 border-l-2 border-yellow-600' :
                                        log.type === 'combat' ? 'bg-red-900/20 text-red-100 border-l-2 border-red-600' :
                                        log.type === 'action' ? 'bg-gray-700/50 text-gray-300 text-right italic' :
                                        log.type === 'success' ? 'bg-green-900/30 text-green-200 border-l-2 border-green-500' :
                                        log.type === 'danger' ? 'bg-red-600 text-white font-bold text-center' :
                                        'text-gray-300'
                                    }`}>
                                        {log.text}
                                    </div>
                                ))}
                                {processing && (
                                    <div className="flex items-center gap-2 text-gray-400 italic p-2">
                                        <span className="animate-spin">âœ¦</span> AI æ­£åœ¨ç”Ÿæˆ...
                                    </div>
                                )}
                            </div>

                            {/* Input / Controls Area */}
                            <div className="bg-gray-800 p-4 rounded border border-gray-600 shadow-lg z-10">
                                {phase === 'adventure' ? (
                                    // Adventure Controls
                                    <div className="flex gap-2">
                                        <button
                                            onClick={() => setShowDice(!showDice)}
                                            className={`px-3 rounded border ${showDice ? 'bg-purple-700 border-purple-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                            title="æ‰“å¼€æ·éª°å™¨"
                                        >
                                            ğŸ²
                                        </button>
                                        <input
                                            type="text"
                                            value={inputAction}
                                            onChange={(e) => setInputAction(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && handleAdventureAction()}
                                            placeholder="è¾“å…¥ä½ çš„è¡ŒåŠ¨ (ä¾‹å¦‚: å‘åŒ—æ¢ç´¢ï¼Œå¯»æ‰¾æ°´æºï¼Œè°ƒæŸ¥ç¥åº™...)"
                                            className="flex-1 p-3 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                            disabled={processing}
                                        />
                                        <button
                                            onClick={handleAdventureAction}
                                            disabled={processing || !inputAction.trim()}
                                            className="px-6 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded shadow disabled:opacity-50"
                                        >
                                            è¡ŒåŠ¨
                                        </button>
                                    </div>
                                ) : (
                                    // Combat Controls
                                    <div className="space-y-3">
                                        <div className="flex justify-between items-center text-xs text-gray-400 uppercase tracking-wider">
                                            <div className="flex items-center gap-2">
                                                <span>æˆ˜æ–—æ¨¡å¼</span>
                                                <label className="flex items-center gap-1 cursor-pointer hover:text-gray-300" title="å¼€å¯/å…³é—­ AI æˆ˜æ–—è§£è¯´">
                                                     <input 
                                                        type="checkbox" 
                                                        checked={showNarrative} 
                                                        onChange={(e) => setShowNarrative(e.target.checked)} 
                                                        className="accent-purple-500" 
                                                    />
                                                     <span>è§£è¯´</span>
                                                </label>
                                            </div>
                                            <div className="flex gap-2 items-center">
                                                <button 
                                                    onClick={() => setShowDice(!showDice)}
                                                    className="text-purple-400 hover:text-purple-300 flex items-center gap-1"
                                                >
                                                    <span>ğŸ² æ·éª°å™¨</span>
                                                </button>
                                                <span>å½“å‰ç›®æ ‡: {enemies[selectedTargetIndex]?.name || "æ— "}</span>
                                            </div>
                                        </div>
                                        
                                        {/* Skills */}
                                        <div className="flex flex-col gap-2">
                                            {/* Active Skills */}
                                            <div className="flex gap-2 flex-wrap">
                                                {player.skills.filter(s => s.type !== 'passive').map((skill, i) => (
                                                    <button
                                                        key={i}
                                                        onClick={() => handleCombatAction('skill', skill)}
                                                        disabled={processing || player.stats.hp <= 0}
                                                        className="flex flex-col items-start px-3 py-2 bg-red-700 hover:bg-red-600 text-white rounded shadow border-b-4 border-red-900 active:border-0 active:translate-y-1 disabled:opacity-50 disabled:translate-y-0 disabled:border-b-4 min-w-[120px]"
                                                        title={`${skill.name}\nç±»å‹: ${skill.type === 'active' ? 'ä¸»åŠ¨' : 'è¢«åŠ¨'}\næ¶ˆè€—: ${skill.cost} ${skill.costType}\nä¼¤å®³/å¼ºåº¦: ${skill.damage}\nç›®æ ‡: ${skill.target}\næ•ˆæœ: ${skill.statusEffects ? skill.statusEffects.join(',') : 'æ— '}\n\n${skill.description}`}
                                                    >
                                                        <span className="font-bold text-sm">{skill.name}</span>
                                                        <div className="flex gap-1 text-[10px] opacity-80 mt-1">
                                                            {skill.cost > 0 && <span>{skill.cost}{skill.costType}</span>}
                                                            {skill.target && <span className="bg-black/30 px-1 rounded">{skill.target === 'aoe' ? 'èŒƒå›´' : skill.target === 'self' ? 'è‡ªèº«' : 'å•ä½“'}</span>}
                                                        </div>
                                                    </button>
                                                ))}
                                            </div>
                                            
                                            {/* Passive Skills */}
                                            {player.skills.some(s => s.type === 'passive') && (
                                                <div className="bg-gray-700/50 p-2 rounded border border-gray-600 flex flex-wrap gap-2">
                                                    <span className="text-xs text-gray-400 uppercase font-bold">è¢«åŠ¨æŠ€èƒ½:</span>
                                                    {player.skills.filter(s => s.type === 'passive').map((skill, i) => (
                                                        <div key={i} className="text-xs bg-gray-800 px-2 py-1 rounded text-gray-300 border border-gray-700 cursor-help" title={`${skill.name}\n${skill.description}`}>
                                                            {skill.name}
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>

                                        {/* Custom Combat Action */}
                                        <div className="flex gap-2">
                                            <input
                                                type="text"
                                                value={inputAction}
                                                onChange={(e) => setInputAction(e.target.value)}
                                                onKeyDown={(e) => e.key === 'Enter' && handleCombatAction('custom')}
                                                placeholder="å°è¯•ç‰¹æ®Šæˆ˜æ–—è¡ŒåŠ¨ (ä¾‹å¦‚: å¯»æ‰¾æ©ä½“ï¼ŒæŠ•æ·æ²™çŸ³...)"
                                                className="flex-1 p-2 rounded bg-gray-700 border border-gray-600 focus:border-red-500 focus:outline-none text-white text-sm"
                                                disabled={processing}
                                            />
                                            <button
                                                onClick={() => handleCombatAction('custom')}
                                                disabled={processing || !inputAction.trim()}
                                                className="px-4 bg-gray-600 hover:bg-gray-500 text-white text-sm font-bold rounded disabled:opacity-50"
                                            >
                                                æ‰§è¡Œ
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* RIGHT PANEL: Enemy List (Combat) */}
                        <div className={`lg:w-72 shrink-0 flex flex-col gap-4 ${phase !== 'combat' ? 'hidden lg:flex lg:invisible' : ''}`}>
                            {phase === 'combat' && (
                                <div className="bg-gray-800 p-4 rounded border border-gray-600 overflow-y-auto max-h-60 lg:max-h-full">
                                    <h3 className="text-sm font-bold text-red-400 mb-2 sticky top-0 bg-gray-800">æ•Œäººåˆ—è¡¨ (ç‚¹å‡»é€‰æ‹©ç›®æ ‡)</h3>
                                    <div className="space-y-2">
                                        {enemies.map((enemy, idx) => (
                                            <div 
                                                key={idx}
                                                onClick={() => setSelectedTargetIndex(idx)}
                                                title={`${enemy.description || ''}\n${enemy.traits ? "ç‰¹æ€§: " + enemy.traits.map(t => t.name + "(" + t.description + ")").join(", ") : ""}\n${enemy.skills ? "æŠ€èƒ½: " + enemy.skills.join(", ") : ""}`}
                                                className={`p-2 rounded border cursor-pointer transition-colors ${
                                                    selectedTargetIndex === idx 
                                                    ? 'bg-red-900/40 border-red-500' 
                                                    : 'bg-gray-700/50 border-transparent hover:bg-gray-700'
                                                }`}
                                            >
                                                <div className="flex justify-between items-center">
                                                    <span className={selectedTargetIndex === idx ? "text-red-300 font-bold" : "text-gray-300"}>
                                                        {enemy.name}
                                                    </span>
                                                    <div className="flex flex-col items-end">
                                                        <span className="text-xs text-gray-400">HP: {Math.floor(enemy.stats.hp)}/{enemy.stats.maxHp}</span>
                                                        {enemy.buffs && enemy.buffs.length > 0 && (
                                                            <div className="flex gap-1 mt-1">
                                                                {enemy.buffs.map((b, bi) => (
                                                                    <span key={bi} className="w-2 h-2 rounded-full bg-yellow-500" title={`${b.name}: ${b.description}`}></span>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                                <div className="w-full bg-gray-900 rounded-full h-1.5 mt-1">
                                                    <div 
                                                        className="bg-red-500 h-full rounded-full transition-all duration-500" 
                                                        style={{ width: `${Math.min(100, (enemy.stats.hp / enemy.stats.maxHp) * 100)}%` }}
                                                    ></div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>

                    </div>
                </div>
            );
        }

        function App() {
            const [gameConfig, setGameConfig] = useState(null);
            const [character, setCharacter] = useState(null);

            const handleConnect = (config) => {
                setGameConfig(config);
            };

            if (!gameConfig) {
                return <ConfigScreen onConnect={handleConnect} />;
            }

            return (
                <>
                    {!character ? (
                        <CharacterCreation onCharacterCreated={setCharacter} config={gameConfig} />
                    ) : (
                        <GameInterface character={character} config={gameConfig} />
                    )}
                </>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
