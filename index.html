<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI RPG Game (Multi-Model)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; 
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; 
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        const { useState, useEffect, useRef } = React;

        // --- Configuration & Models ---

        const PROVIDERS = {
            GOOGLE: "google",
            OPENAI: "openai",
            DEEPSEEK: "deepseek",
            ANTHROPIC: "anthropic"
        };

        const AVAILABLE_MODELS = [
            // Google Models
            { id: "gemini-3-pro-preview", name: "Gemini 3.0 Pro Preview (Paid)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-2.5-pro", name: "Gemini 2.5 Pro (Thinking Model)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-2.0-pro-exp", name: "Gemini 2.0 Pro Exp (If Available)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-1.5-pro", name: "Gemini 1.5 Pro (Free Tier)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-1.5-flash", name: "Gemini 1.5 Flash (Fast)", provider: PROVIDERS.GOOGLE },
            // DeepSeek Models
            { id: "deepseek-chat", name: "DeepSeek V3 (Chat)", provider: PROVIDERS.DEEPSEEK },
            { id: "deepseek-reasoner", name: "DeepSeek R1 (Reasoner)", provider: PROVIDERS.DEEPSEEK },
            // Anthropic Models (Simulated Date: Nov 2025)
            { id: "claude-3-7-sonnet-20250219", name: "Claude 3.7 Sonnet (Latest)", provider: PROVIDERS.ANTHROPIC },
            { id: "claude-3-5-sonnet-20241022", name: "Claude 3.5 Sonnet", provider: PROVIDERS.ANTHROPIC },
            { id: "claude-3-opus-20240229", name: "Claude 3 Opus", provider: PROVIDERS.ANTHROPIC },
            // OpenAI / Compatible Models
            { id: "gpt-4o", name: "GPT-4o", provider: PROVIDERS.OPENAI },
            { id: "gpt-4-turbo", name: "GPT-4 Turbo", provider: PROVIDERS.OPENAI },
            { id: "gpt-3.5-turbo", name: "GPT-3.5 Turbo", provider: PROVIDERS.OPENAI },
            { id: "custom", name: "Custom Model ID", provider: PROVIDERS.OPENAI }
        ];

        const DEFAULT_CONFIG = {
            provider: PROVIDERS.GOOGLE,
            model: "gemini-1.5-pro",
            baseUrl: "https://generativelanguage.googleapis.com", // Default Google URL
            apiKey: ""
        };

        // --- AI Service Implementation ---

        const callAI = async (config, messages, jsonMode = true) => {
            const { provider, model, baseUrl, apiKey } = config;

            try {
                if (provider === PROVIDERS.GOOGLE) {
                    // --- Google Gemini API ---
                    let promptText = "";
                    messages.forEach(msg => {
                        promptText += `${msg.role === 'system' ? 'System Instruction' : 'User Input'}: ${msg.content}\n\n`;
                    });

                    // Use configured baseUrl (allows proxy usage)
                    // Ensure no trailing slash
                    const cleanBaseUrl = (baseUrl || "https://generativelanguage.googleapis.com").replace(/\/$/, "");
                    const url = `${cleanBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`;

                    const response = await fetch(url, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: promptText }] }],
                            generationConfig: {
                                responseMimeType: jsonMode ? "application/json" : "text/plain"
                            }
                        })
                    });

                    if (!response.ok) {
                        const err = await response.json().catch(() => ({}));
                        throw new Error(err.error?.message || `Google API Error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    if (!data.candidates || data.candidates.length === 0) throw new Error("No content generated");
                    const content = data.candidates[0].content.parts[0].text;
                    return jsonMode ? JSON.parse(content) : content;

                } else if (provider === PROVIDERS.ANTHROPIC) {
                    // --- Anthropic API ---
                    let url = baseUrl.replace(/\/$/, "");
                    if (!url.endsWith("/v1/messages")) {
                        url += "/v1/messages";
                    }

                    const systemMessage = messages.find(m => m.role === 'system')?.content || "";
                    const userMessages = messages.filter(m => m.role !== 'system').map(m => ({
                        role: m.role,
                        content: m.content
                    }));

                    const body = {
                        model: model,
                        max_tokens: 4096,
                        system: systemMessage,
                        messages: userMessages,
                        temperature: 0.7
                    };

                    // Note: Anthropic API requires CORS proxy or browser-specific handling
                    const response = await fetch(url, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "x-api-key": apiKey,
                            "anthropic-version": "2023-06-01",
                            "anthropic-dangerous-direct-browser-access": "true"
                        },
                        body: JSON.stringify(body)
                    });

                    if (!response.ok) {
                        const err = await response.json().catch(() => ({}));
                        throw new Error(err.error?.message || `Anthropic API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    const textBlock = data.content.find(b => b.type === 'text');
                    if (!textBlock) throw new Error("No text content in Anthropic response");
                    
                    const content = textBlock.text;
                    if (jsonMode) {
                        // Try to find JSON block
                        const jsonMatch = content.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            return JSON.parse(jsonMatch[0]);
                        }
                        return JSON.parse(content);
                    }
                    return content;

                } else {
                    // --- OpenAI Compatible API (DeepSeek / OpenAI) ---
                    let url = baseUrl.replace(/\/$/, "");
                    if (!url.endsWith("/chat/completions")) {
                        url += "/chat/completions";
                    }

                    const body = {
                        model: model === 'custom' ? 'gpt-3.5-turbo' : model, 
                        messages: messages,
                        temperature: 0.7,
                        response_format: jsonMode ? { type: "json_object" } : undefined
                    };

                    const response = await fetch(url, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(body)
                    });

                    if (!response.ok) {
                        const err = await response.json().catch(() => ({}));
                        throw new Error(err.error?.message || `API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    const content = data.choices[0].message.content;
                    return jsonMode ? JSON.parse(content) : content;
                }
            } catch (error) {
                console.error("AI Service Error:", error);
                throw error;
            }
        };

        // --- Prompts (Unchanged) ---

        const getCharGenPrompt = (worldview, description) => {
            return [
                {
                    role: "system",
                    content: `You are a creative RPG Game Master. Create a character based on the user's input.
                    IMPORTANT: All user-facing strings (name, class, skills description, story) MUST be in Simplified Chinese (ç®€ä½“ä¸­æ–‡).
                    
                    Return ONLY valid JSON matching this structure:
                    {
                        "name": "string (Chinese Name)",
                        "class": "string (Chinese Class)",
                        "stats": { 
                            "hp": number (50-500), 
                            "maxHp": number (same as hp), 
                            "mp": number (0-200), 
                            "maxMp": number (same as mp),
                            "stamina": number (0-100),
                            "maxStamina": number (same as stamina),
                            "attack": number (10-100), 
                            "defense": number (5-50), 
                            "speed": number (5-50) 
                            // Add other relevant stats based on description
                        },
                        "skills": [
                            { 
                                "name": "string (Chinese Skill Name)", 
                                "type": "active"|"passive", 
                                "damage": number (0-100, 0 for passive/buff), 
                                "cost": number (0-50), 
                                "costType": "mp"|"stamina"|"energy"|"none", 
                                "target": "single"|"aoe"|"self"|"all_enemies", 
                                "statusEffects": ["string (e.g. 'burn', 'freeze', 'poison', 'stun', 'disarm', 'bind')"],
                                "description": "string (Chinese)" 
                            }
                        ],
                        "items": [
                            { "name": "string (Chinese Name)", "type": "consumable"|"equipment"|"material", "effect": { "hp": number, "mp": number }, "count": number, "description": "string" }
                        ],
                        "story": "string (Rich backstory in Chinese)"
                    }
                    
                    Guidance:
                    - Create 4 to 8 skills depending on the class complexity.
                    - Include diverse mechanics: Damage, Heals, Buffs, Debuffs.
                    - Include 1-2 Passive skills if appropriate.
                    - Give the character 3-5 starting items (e.g. Health Potion, Rations, Map, Weapon).
                    - Ensure resource costs match the stats provided.`
                },
                {
                    role: "user",
                    content: `World Setting: ${worldview}\nCharacter Description: ${description}`
                }
            ];
        };

        // Prompt for Adventure Phase (Exploration)
        const getAdventurePrompt = (player, history, action) => {
             const lastLog = history.length > 0 ? history[history.length - 1].text : "";
             return [
                {
                    role: "system",
                    content: `You are an RPG Game Master (DM). The player is exploring the world.
                    Current Player: ${player.name} (${player.class}).
                    Stats: ${JSON.stringify(player.stats)}.
                    Inventory: ${JSON.stringify(player.items || [])}.
                    
                    The user performs an action. Describe the outcome in a RICH, ENGAGING, NOVEL-LIKE STYLE.
                    
                    Style Guidelines:
                    - Use sensory details (what does the player see, hear, smell?).
                    - Be verbose rather than brief (3-5 paragraphs is good).
                    - Provide clear guidance or "hooks" for what the player can do next (e.g. "You notice a glimmer in the dark corner...", "The path splits into two...").
                    - If the player seems lost, give them a hint.

                    IF THE USER INPUT CONTAINS A DICE ROLL (e.g. "(ğŸ² 1d20: 15)"):
                    - Respect the result.
                    - If high (e.g. > 10 for d20), the action succeeds better.
                    - If low (e.g. < 5 for d20), the action might fail or have consequences.
                    - Mention the roll result in the narrative (e.g. "ä½ æ·å‡ºäº†15ç‚¹ï¼Œè½»æ¾è·³è¿‡äº†é™·é˜±").

                    IMPORTANT: Narrative MUST be in Simplified Chinese (ç®€ä½“ä¸­æ–‡).
                    
                    Return ONLY valid JSON:
                    {
                        "narrative": "string (Long, descriptive narrative)",
                        "statChanges": { "hp": number, "mp": number, ... }, // Optional: Relative changes to stats
                        "newItems": [ // Optional: Items found
                            { "name": "string", "type": "consumable"|"equipment"|"material", "effect": { "hp": number, "mp": number }, "count": number, "description": "string" }
                        ],
                        "removedItems": ["string (Item Name)"], // Optional: Items used/lost
                        "newEnemies": [ // Optional: Only if combat starts
                            { "name": "string", "stats": { "hp": number, "maxHp": number, "attack": number, "defense": number, "speed": number } }
                        ]
                    }
                    `
                },
                {
                    role: "user",
                    content: `Previous: ${lastLog}\nPlayer Action: ${action}`
                }
            ];
        };

        // Prompt for Combat Phase (Multi-Enemy)
        const getCombatPrompt = (player, enemies, action, targetIndex, history) => {
            const lastLog = history.length > 0 ? history[history.length - 1].text : "";
            
            // Construct enemy state string
            const enemyState = enemies.map((e, i) => `[${i}] ${e.name}: HP ${e.stats.hp}/${e.stats.maxHp}`).join(", ");
            
            // Construct player skills string for context
            const playerSkills = player.skills.map(s => `${s.name} (${s.type}, ${s.cost}${s.costType})`).join(", ");

            return [
                {
                    role: "system",
                    content: `You are an RPG Combat Narrator. 
                    The player is fighting ${enemies.length} enemies.
                    
                    Player: ${player.name} (HP ${player.stats.hp}/${player.stats.maxHp}, ATK ${player.stats.attack}, DEF ${player.stats.defense}).
                    Player Skills/Passives: ${playerSkills}
                    Enemies: ${enemyState}
                    
                    Action: ${JSON.stringify(action)}
                    Target Index: ${targetIndex} (The enemy being attacked by player)
                    
                    IF THE USER ACTION CONTAINS A DICE ROLL (e.g. "(ğŸ² 1d20: 20)"):
                    - Use it to determine hit/crit/miss if applicable.
                    - High rolls (e.g. near max) should be critical hits or special effects.
                    - Low rolls might miss.

                    Style Guidelines:
                    - Describe the combat moves vividly (sparks flying, heavy impacts, magical auras).
                    - If the player uses a skill with effects (Freeze, Burn, Poison), describe those effects triggering on the enemy.
                    - Account for Passive skills if relevant (e.g. if player has "Thick Skin", mention they took less damage).

                    IMPORTANT: Narrative MUST be in Simplified Chinese (ç®€ä½“ä¸­æ–‡).
                    
                    Return ONLY valid JSON:
                    {
                        "narrative": "string (Vivid combat description)",
                        "playerDamageTaken": number (Total damage player took from ALL enemies this turn),
                        "enemiesUpdates": [
                            { "index": number, "damageTaken": number, "statusAdded": "string (optional)" } // Damage taken by specific enemies
                        ]
                    }
                    Rules:
                    - Calculate player damage to Target.
                    - All surviving enemies attack the player.
                    - Sum up damage to player.
                    `
                },
                {
                    role: "user",
                    content: `Execute Combat Turn.`
                }
            ];
        };

        // --- Helper Functions ---
        
        const rollDice = (expression) => {
            try {
                // Simple parser for XdY+Z format
                const regex = /^(\d+)d(\d+)(?:\+([-]?\d+))?$/i;
                const match = expression.trim().match(regex);
                
                if (!match) {
                    // Try parsing just a number
                    const num = parseInt(expression);
                    if (!isNaN(num)) return { total: num, details: `${num}`, expression };
                    throw new Error("æ— æ•ˆçš„è¡¨è¾¾å¼ã€‚æ ¼å¼ç¤ºä¾‹: 2d6, 1d20+5");
                }

                const count = parseInt(match[1]);
                const sides = parseInt(match[2]);
                const modifier = match[3] ? parseInt(match[3]) : 0;

                if (count > 50) throw new Error("éª°å­æ•°é‡è¿‡å¤š");
                if (sides > 1000) throw new Error("éª°å­é¢æ•°è¿‡å¤š");

                let total = 0;
                const rolls = [];
                for (let i = 0; i < count; i++) {
                    const roll = Math.floor(Math.random() * sides) + 1;
                    rolls.push(roll);
                    total += roll;
                }
                total += modifier;

                const details = `[${rolls.join(",")}]${modifier !== 0 ? (modifier > 0 ? `+${modifier}` : modifier) : ""} = ${total}`;
                return { total, details, expression };
            } catch (e) {
                return { error: e.message };
            }
        };

        // --- Components ---

        function ConfigScreen({ onConnect }) {
            const [config, setConfig] = useState(() => {
                const saved = localStorage.getItem("ai_rpg_config");
                return saved ? JSON.parse(saved) : DEFAULT_CONFIG;
            });
            
            const [customModel, setCustomModel] = useState("");

            useEffect(() => {
                localStorage.setItem("ai_rpg_config", JSON.stringify(config));
            }, [config]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (config.apiKey.trim().length > 0) {
                    const finalConfig = { ...config };
                    if (config.model === 'custom') {
                        finalConfig.model = customModel;
                    }
                    onConnect(finalConfig);
                }
            };

            const handleProviderChange = (newProvider) => {
                let newBaseUrl = "";
                if (newProvider === PROVIDERS.GOOGLE) newBaseUrl = "https://generativelanguage.googleapis.com";
                else if (newProvider === PROVIDERS.DEEPSEEK) newBaseUrl = "https://api.deepseek.com";
                else if (newProvider === PROVIDERS.ANTHROPIC) newBaseUrl = "https://api.anthropic.com";
                else newBaseUrl = "https://api.openai.com/v1";

                setConfig(prev => ({
                    ...prev,
                    provider: newProvider,
                    // Default to first model of that provider
                    model: AVAILABLE_MODELS.find(m => m.provider === newProvider)?.id || 'custom',
                    baseUrl: newBaseUrl
                }));
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-900 text-gray-200">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-lg max-w-md w-full border border-gray-700 space-y-6">
                        <div>
                            <h1 className="text-2xl font-bold text-center text-purple-400">æ¸¸æˆè®¾ç½® (Game Config)</h1>
                            <p className="text-center text-xs text-gray-500 mt-1">é€‰æ‹©ä½ çš„ AI å¼•æ“</p>
                        </div>

                        <form onSubmit={handleSubmit} className="space-y-4">
                            {/* Provider Selection */}
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-400">AI æä¾›å•† (Provider)</label>
                                <div className="flex gap-2 flex-wrap">
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.GOOGLE)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.GOOGLE ? 'bg-purple-600 border-purple-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        Google
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.DEEPSEEK)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.DEEPSEEK ? 'bg-blue-600 border-blue-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        DeepSeek
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.ANTHROPIC)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.ANTHROPIC ? 'bg-orange-600 border-orange-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        Claude
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.OPENAI)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.OPENAI ? 'bg-green-600 border-green-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        OpenAI
                                    </button>
                                </div>
                            </div>

                            {/* Model Selection */}
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-400">æ¨¡å‹ (Model)</label>
                                <select
                                    value={config.model}
                                    onChange={(e) => setConfig({...config, model: e.target.value})}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                >
                                    {AVAILABLE_MODELS.filter(m => m.provider === config.provider).map(m => (
                                        <option key={m.id} value={m.id}>{m.name}</option>
                                    ))}
                                    {config.provider === PROVIDERS.OPENAI && <option value="custom">è‡ªå®šä¹‰ / å…¶ä»–...</option>}
                                </select>
                            </div>

                            {/* Custom Model Input (Only if custom selected) */}
                            {config.model === 'custom' && (
                                <div>
                                    <label className="block text-sm font-medium mb-1 text-gray-400">è‡ªå®šä¹‰æ¨¡å‹ ID</label>
                                    <input
                                        type="text"
                                        value={customModel}
                                        onChange={(e) => setCustomModel(e.target.value)}
                                        className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                        placeholder="ä¾‹å¦‚ï¼šclaude-3-opus..."
                                        required
                                    />
                                </div>
                            )}

                            {/* API Key */}
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-400">API å¯†é’¥ (Key)</label>
                                <input 
                                    type="password" 
                                    value={config.apiKey}
                                    onChange={(e) => setConfig({...config, apiKey: e.target.value})}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                    placeholder={
                                        config.provider === PROVIDERS.GOOGLE ? "AIza..." : 
                                        config.provider === PROVIDERS.ANTHROPIC ? "sk-ant-..." :
                                        "sk-..."
                                    }
                                    required
                                />
                                {config.provider === PROVIDERS.ANTHROPIC && (
                                    <p className="text-[10px] text-orange-400 mt-1">
                                        æ³¨æ„: ç›´æ¥åœ¨æµè§ˆå™¨ä½¿ç”¨ Anthropic Key å¯èƒ½ä¼šå› ä¸º CORS å¤±è´¥ã€‚å»ºè®®ä½¿ç”¨è½¬å‘ä»£ç†åœ°å€ (Base URL)ã€‚
                                    </p>
                                )}
                            </div>

                            <button 
                                type="submit" 
                                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-200 mt-4"
                            >
                                è¿æ¥å¹¶å¼€å§‹ (Connect)
                            </button>
                        </form>
                    </div>
                </div>
            );
        }

        function CharacterCreation({ onCharacterCreated, config }) {
            const [worldview, setWorldview] = useState("èµ›åšæœ‹å…‹");
            const [description, setDescription] = useState("ä¸€ä¸ªæ‹¥æœ‰æœºæ¢°è‡‚çš„æµæµªé»‘å®¢ã€‚");
            const [loading, setLoading] = useState(false);

            const handleSubmit = async (e) => {
                e.preventDefault();
                setLoading(true);
                try {
                    const messages = getCharGenPrompt(worldview, description);
                    const charData = await callAI(config, messages);
                    onCharacterCreated(charData);
                } catch (error) {
                    alert("ç”Ÿæˆè§’è‰²å¤±è´¥: " + error.message);
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-4">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-lg max-w-md w-full border border-gray-700">
                        <h1 className="text-3xl font-bold mb-6 text-center text-purple-400">AI RPG ç”Ÿæˆå™¨</h1>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-300">ä¸–ç•Œè§‚è®¾å®š</label>
                                <input 
                                    type="text" 
                                    value={worldview}
                                    onChange={(e) => setWorldview(e.target.value)}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                    placeholder="ä¾‹å¦‚ï¼šèµ›åšæœ‹å…‹ 2077ï¼Œé«˜é­”å¥‡å¹»..."
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-300">è§’è‰²æè¿°</label>
                                <textarea 
                                    value={description}
                                    onChange={(e) => setDescription(e.target.value)}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white h-32"
                                    placeholder="æè¿°ä½ çš„è‹±é›„..."
                                />
                            </div>
                            <button 
                                type="submit" 
                                disabled={loading}
                                className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition duration-200 disabled:opacity-50 flex justify-center items-center gap-2"
                            >
                                {loading ? "æ­£åœ¨æ„æ€..." : "å¼€å§‹å†’é™©"}
                            </button>
                        </form>
                        <div className="text-center mt-4 text-xs text-gray-500">
                            è¿è¡Œæ¨¡å‹ï¼š{config.model}
                        </div>
                    </div>
                </div>
            );
        }

        function GameInterface({ character, config }) {
            const [player, setPlayer] = useState(character);
            // Phase: 'adventure' (Exploration) or 'combat'
            const [phase, setPhase] = useState('adventure'); 
            
            const [enemies, setEnemies] = useState([]);
            const [selectedTargetIndex, setSelectedTargetIndex] = useState(0);
            
            const [logs, setLogs] = useState([
                { text: character.story, type: 'narrative' },
                { text: "å†’é™©å¼€å§‹äº†ã€‚ä½ å¯ä»¥è¾“å…¥è¡ŒåŠ¨æ¥æ¢ç´¢è¿™ä¸ªä¸–ç•Œã€‚", type: 'narrative' }
            ]);
            
            const [inputAction, setInputAction] = useState("");
            const [processing, setProcessing] = useState(false);
            const [showDice, setShowDice] = useState(false);
            const [diceExpression, setDiceExpression] = useState("1d20");
            const [showInventory, setShowInventory] = useState(false);

            const logContainerRef = useRef(null);
            const fileInputRef = useRef(null);

            // --- Export / Import Handlers ---
            const handleExport = () => {
                const gameState = {
                    player,
                    phase,
                    enemies,
                    selectedTargetIndex,
                    logs,
                    timestamp: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(gameState, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai-rpg-save-${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const handleImportClick = () => {
                fileInputRef.current.click();
            };

            const handleImportFile = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const gameState = JSON.parse(e.target.result);
                        // Basic validation
                        if (gameState.player && Array.isArray(gameState.logs)) {
                            setPlayer(gameState.player);
                            setPhase(gameState.phase || 'adventure');
                            setEnemies(gameState.enemies || []);
                            if (gameState.selectedTargetIndex !== undefined) setSelectedTargetIndex(gameState.selectedTargetIndex);
                            setLogs(gameState.logs);
                            // Add a system log to indicate success (without adding to history for export potentially, but useful for user)
                            // We actually replace logs, so we should probably append this success message to the loaded logs 
                            // OR just rely on the state update. But appending is nicer.
                            // However, since logs is state, we can't easily append *after* setLogs in the same tick reliably for display if we just replaced it.
                            // But we can append to the array before setting.
                            const newLogs = [...gameState.logs, { text: "âœ… å­˜æ¡£/è®°å½•å·²æˆåŠŸå¯¼å…¥ï¼", type: "success" }];
                            setLogs(newLogs);
                        } else {
                            throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘å¿…è¦æ•°æ®");
                        }
                    } catch (err) {
                        alert("å¯¼å…¥å¤±è´¥: " + err.message);
                    }
                };
                reader.readAsText(file);
                event.target.value = ''; // Reset
            };

            useEffect(() => {
                if (logContainerRef.current) {
                    logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
                }
            }, [logs]);

            const addLog = (text, type = 'neutral') => {
                setLogs(prev => [...prev, { text, type }]);
            };

            const handleRollDice = (e) => {
                e.preventDefault(); // Prevent form submission if inside a form
                const result = rollDice(diceExpression);
                if (result.error) {
                    addLog(`ğŸ² æ·éª°é”™è¯¯: ${result.error}`, 'danger');
                } else {
                    const rollText = `(ğŸ² ${result.expression}: ${result.details})`;
                    setInputAction(prev => (prev ? prev + " " + rollText : rollText));
                    addLog(`ğŸ² æ·éª°æ£€å®š: ${result.expression} => ${result.details}`, 'action');
                    setShowDice(false);
                }
            };

            const handleUseItem = (itemIndex) => {
                const item = player.items[itemIndex];
                if (!item) return;

                // Apply effects if consumable
                if (item.type === 'consumable' && item.effect) {
                    setPlayer(prev => {
                        const newStats = { ...prev.stats };
                        Object.entries(item.effect).forEach(([key, value]) => {
                            if (typeof newStats[key] !== 'undefined') {
                                const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                                newStats[key] = newStats[key] + value;
                                if (typeof newStats[maxKey] !== 'undefined') {
                                    newStats[key] = Math.min(newStats[key], newStats[maxKey]);
                                }
                            }
                        });
                        
                        // Decrease count or remove
                        const newItems = [...prev.items];
                        newItems[itemIndex].count--;
                        if (newItems[itemIndex].count <= 0) {
                            newItems.splice(itemIndex, 1);
                        }
                        
                        return { ...prev, stats: newStats, items: newItems };
                    });
                    addLog(`ä½¿ç”¨äº† ${item.name}`, 'success');
                    
                    // In combat, using an item might take a turn? 
                    // For now, let's assume it's a free action or part of the narrative action 
                    // But if in combat, we might want to trigger a turn update.
                    // Let's keep it simple: Using item from UI is "instant" but maybe we should tell AI?
                    // Ideally, using item should be an action sent to AI.
                    // But for now, let's just update stats locally.
                } else {
                    addLog(`${item.name} æ— æ³•ç›´æ¥ä½¿ç”¨`, 'neutral');
                }
            };

            // --- Adventure Phase Handler ---
            const handleAdventureAction = async () => {
                if (processing || !inputAction.trim()) return;
                const action = inputAction.trim();
                setInputAction("");
                setProcessing(true);
                addLog(`> ${action}`, 'action');

                try {
                    const messages = getAdventurePrompt(player, logs, action);
                    const result = await callAI(config, messages);
                    
                    addLog(result.narrative, 'narrative');

                    // Handle Stat Changes (Healing/Items)
                    setPlayer(prev => {
                        let newStats = { ...prev.stats };
                        let newItems = prev.items ? [...prev.items] : [];

                        if (result.statChanges) {
                            Object.entries(result.statChanges).forEach(([key, value]) => {
                                if (typeof newStats[key] !== 'undefined') {
                                    newStats[key] = newStats[key] + value;
                                    const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                                    if (typeof newStats[maxKey] !== 'undefined') {
                                        newStats[key] = Math.min(newStats[key], newStats[maxKey]);
                                    }
                                    newStats[key] = Math.max(0, newStats[key]);
                                }
                            });
                        }

                        // Handle New Items
                        if (result.newItems) {
                            result.newItems.forEach(newItem => {
                                const existingItemIndex = newItems.findIndex(i => i.name === newItem.name);
                                if (existingItemIndex >= 0) {
                                    newItems[existingItemIndex].count += newItem.count;
                                } else {
                                    newItems.push(newItem);
                                }
                                addLog(`è·å¾—ç‰©å“: ${newItem.name} x${newItem.count}`, 'success');
                            });
                        }

                        // Handle Removed Items
                        if (result.removedItems) {
                            result.removedItems.forEach(remName => {
                                const idx = newItems.findIndex(i => i.name === remName);
                                if (idx >= 0) {
                                    newItems[idx].count--;
                                    if (newItems[idx].count <= 0) newItems.splice(idx, 1);
                                }
                            });
                        }

                        return { ...prev, stats: newStats, items: newItems };
                    });

                    if (result.newEnemies && result.newEnemies.length > 0) {
                        setEnemies(result.newEnemies);
                        setPhase('combat');
                        setSelectedTargetIndex(0);
                        addLog(`âš ï¸ é­é‡æ•Œè¢­ï¼å‡ºç° ${result.newEnemies.length} ä¸ªæ•Œäººï¼`, 'danger');
                    }

                } catch (error) {
                    addLog(`é”™è¯¯: ${error.message}`, 'danger');
                } finally {
                    setProcessing(false);
                }
            };

            // --- Combat Phase Handler ---
            const handleCombatAction = async (actionType, skill = null) => {
                if (processing || player.stats.hp <= 0) return;
                
                // Construct action object (Skill or Custom Text)
                let actionObj = {};
                if (skill) {
                    actionObj = { 
                        name: skill.name, 
                        type: skill.type, 
                        damage: skill.damage, 
                        cost: skill.cost,
                        target: skill.target,
                        effects: skill.statusEffects || []
                    };
                } else {
                    if (!inputAction.trim()) return;
                    actionObj = { name: inputAction.trim(), type: 'custom' };
                    setInputAction("");
                }

                setProcessing(true);
                addLog(`> ${actionObj.name} (ç›®æ ‡: ${enemies[selectedTargetIndex]?.name || 'æ— '})`, 'action');

                try {
                    const messages = getCombatPrompt(player, enemies, actionObj, selectedTargetIndex, logs);
                    const result = await callAI(config, messages);
                    
                    // Update State based on AI calculation
                    // 1. Apply damage to specific enemies
                    let newEnemies = [...enemies];
                    if (result.enemiesUpdates) {
                        result.enemiesUpdates.forEach(update => {
                            if (newEnemies[update.index]) {
                                const e = newEnemies[update.index];
                                e.stats.hp = Math.max(0, e.stats.hp - update.damageTaken);
                            }
                        });
                    }
                    
                    // 2. Apply damage to player
                    if (result.playerDamageTaken > 0) {
                         setPlayer(prev => ({
                            ...prev,
                            stats: { ...prev.stats, hp: Math.max(0, prev.stats.hp - result.playerDamageTaken) }
                        }));
                    }

                    addLog(result.narrative, 'combat');

                    // 3. Check for Deaths
                    // Filter out dead enemies
                    const aliveEnemies = newEnemies.filter(e => e.stats.hp > 0);
                    setEnemies(aliveEnemies);
                    
                    // Adjust target index if needed
                    if (selectedTargetIndex >= aliveEnemies.length) {
                        setSelectedTargetIndex(Math.max(0, aliveEnemies.length - 1));
                    }

                    if (aliveEnemies.length === 0) {
                        addLog("æ‰€æœ‰æ•Œäººå·²è¢«å‡»è´¥ï¼æˆ˜æ–—ç»“æŸï¼Œä½ å¯ä»¥ç»§ç»­å†’é™©äº†ã€‚", 'success');
                        setPhase('adventure');
                    } else if (player.stats.hp - result.playerDamageTaken <= 0) {
                        addLog("ä½ è¢«æ‰“è´¥äº†... æ¸¸æˆç»“æŸã€‚", 'danger');
                    }

                } catch (error) {
                    addLog(`é”™è¯¯: ${error.message}`, 'danger');
                } finally {
                    setProcessing(false);
                }
            };

            // Helper to render dynamic status bars
            const renderStats = () => {
                const statKeys = Object.keys(player.stats);
                // Find "bar" stats: keys that have a corresponding "maxKey" (e.g. hp/maxHp, mp/maxMp)
                const barStats = [];
                const otherStats = [];

                statKeys.forEach(key => {
                    if (key.startsWith('max')) return; // Skip max keys
                    const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                    if (player.stats[maxKey] !== undefined) {
                        barStats.push({ key, maxKey, label: key.toUpperCase() });
                    } else {
                        otherStats.push({ key, label: key.toUpperCase() });
                    }
                });

                return (
                    <>
                        {/* Bars */}
                        {barStats.map(stat => (
                            <div key={stat.key} className="mb-2">
                                <div className="flex justify-between text-xs uppercase text-gray-400 mb-1">
                                    <span>{stat.key}</span>
                                    <span>{Math.floor(player.stats[stat.key])}/{player.stats[stat.maxKey]}</span>
                                </div>
                                <div className="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                                    <div 
                                        className={`h-full transition-all duration-500 ${
                                            stat.key === 'hp' ? 'bg-green-500' : 
                                            stat.key === 'mp' ? 'bg-blue-500' : 
                                            stat.key === 'stamina' ? 'bg-yellow-500' : 'bg-purple-500'
                                        }`} 
                                        style={{ width: `${Math.min(100, Math.max(0, (player.stats[stat.key] / player.stats[stat.maxKey]) * 100))}%` }}
                                    ></div>
                                </div>
                            </div>
                        ))}
                        
                        {/* Grid for other stats */}
                        <div className="grid grid-cols-3 gap-2 mt-3 text-sm text-gray-400">
                            {otherStats.map(stat => (
                                <div key={stat.key} className="flex flex-col items-center bg-gray-700/30 rounded p-1">
                                    <span className="text-xs text-gray-500 uppercase">{stat.key}</span>
                                    <span className="font-bold text-gray-200">{player.stats[stat.key]}</span>
                                </div>
                            ))}
                        </div>
                    </>
                );
            };

            return (
                <div className="flex flex-col h-screen max-w-5xl mx-auto p-2 md:p-4">
                    {/* Top Bar with Save/Load */}
                    <div className="flex justify-end gap-2 mb-2">
                        <input 
                            type="file" 
                            ref={fileInputRef}
                            onChange={handleImportFile}
                            style={{ display: 'none' }}
                            accept=".json"
                        />
                        <button 
                            onClick={handleImportClick}
                            className="px-3 py-1 text-xs md:text-sm bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 flex items-center gap-1 transition-colors"
                            title="å¯¼å…¥ä¹‹å‰çš„æ¸¸æˆè®°å½•"
                        >
                            ğŸ“‚ å¯¼å…¥è®°å½•
                        </button>
                        <button 
                            onClick={handleExport}
                            className="px-3 py-1 text-xs md:text-sm bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 flex items-center gap-1 transition-colors"
                            title="ä¿å­˜å½“å‰æ¸¸æˆè®°å½•åˆ°æœ¬åœ°"
                        >
                            ğŸ’¾ å¯¼å‡ºè®°å½•
                        </button>
                    </div>

                    {/* Header Stats */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        {/* Player Card */}
                        <div className="bg-gray-800 p-4 rounded border border-gray-600 relative">
                            <div className="flex justify-between items-center mb-3">
                                <h2 className="text-xl font-bold text-purple-400">{player.name}</h2>
                                <div className="flex gap-2">
                                    <button 
                                        onClick={() => setShowInventory(!showInventory)}
                                        className="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded text-gray-300 flex items-center gap-1"
                                    >
                                        ğŸ’ ç‰©å“ ({player.items ? player.items.length : 0})
                                    </button>
                                    <span className="text-xs bg-gray-700 px-2 py-1 rounded text-gray-300">{player.class}</span>
                                </div>
                            </div>
                            
                            {renderStats()}

                            {/* Inventory Overlay */}
                            {showInventory && (
                                <div className="absolute top-12 right-2 w-64 bg-gray-900 border border-gray-500 rounded shadow-xl z-20 max-h-80 overflow-y-auto">
                                    <div className="p-2 border-b border-gray-700 flex justify-between items-center bg-gray-800">
                                        <span className="text-sm font-bold text-gray-200">èƒŒåŒ…</span>
                                        <button onClick={() => setShowInventory(false)} className="text-gray-500 hover:text-white">Ã—</button>
                                    </div>
                                    <div className="p-2 space-y-2">
                                        {player.items && player.items.length > 0 ? (
                                            player.items.map((item, idx) => (
                                                <div key={idx} className="bg-gray-800 p-2 rounded border border-gray-700 text-sm">
                                                    <div className="flex justify-between">
                                                        <span className="font-bold text-purple-300">{item.name}</span>
                                                        <span className="text-gray-400">x{item.count}</span>
                                                    </div>
                                                    <p className="text-xs text-gray-500 mb-1">{item.description}</p>
                                                    {item.type === 'consumable' && (
                                                        <button 
                                                            onClick={() => handleUseItem(idx)}
                                                            className="w-full bg-green-800 hover:bg-green-700 text-green-100 text-xs py-1 rounded"
                                                        >
                                                            ä½¿ç”¨
                                                        </button>
                                                    )}
                                                </div>
                                            ))
                                        ) : (
                                            <div className="text-center text-gray-500 py-4 text-xs">èƒŒåŒ…æ˜¯ç©ºçš„</div>
                                        )}
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Enemy List (Only in Combat) */}
                        {phase === 'combat' && (
                            <div className="bg-gray-800 p-4 rounded border border-gray-600 overflow-y-auto max-h-40">
                                <h3 className="text-sm font-bold text-red-400 mb-2 sticky top-0 bg-gray-800">æ•Œäººåˆ—è¡¨ (ç‚¹å‡»é€‰æ‹©ç›®æ ‡)</h3>
                                <div className="space-y-2">
                                    {enemies.map((enemy, idx) => (
                                        <div 
                                            key={idx}
                                            onClick={() => setSelectedTargetIndex(idx)}
                                            className={`p-2 rounded border cursor-pointer transition-colors ${
                                                selectedTargetIndex === idx 
                                                ? 'bg-red-900/40 border-red-500' 
                                                : 'bg-gray-700/50 border-transparent hover:bg-gray-700'
                                            }`}
                                        >
                                            <div className="flex justify-between items-center">
                                                <span className={selectedTargetIndex === idx ? "text-red-300 font-bold" : "text-gray-300"}>
                                                    {enemy.name}
                                                </span>
                                                <span className="text-xs text-gray-400">HP: {enemy.stats.hp}/{enemy.stats.maxHp}</span>
                                            </div>
                                            <div className="w-full bg-gray-900 rounded-full h-1.5 mt-1">
                                                <div 
                                                    className="bg-red-500 h-full rounded-full transition-all duration-500" 
                                                    style={{ width: `${(enemy.stats.hp / enemy.stats.maxHp) * 100}%` }}
                                                ></div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Main Game Area */}
                    <div className="flex-1 flex flex-col gap-4 overflow-hidden">
                        {/* Log/Narrative Area */}
                        <div 
                            ref={logContainerRef}
                            className="flex-1 bg-gray-900 p-4 rounded border border-gray-700 overflow-y-auto space-y-2 font-mono text-sm md:text-base shadow-inner relative"
                        >
                            {/* Dice Overlay */}
                            {showDice && (
                                <div className="absolute bottom-4 right-4 bg-gray-800 p-3 rounded border border-purple-500 shadow-xl z-20 flex flex-col gap-2 animate-in fade-in slide-in-from-bottom-2">
                                    <span className="text-xs text-purple-300 font-bold">æ·éª°å­ (Dice Roller)</span>
                                    <div className="flex gap-2">
                                        <input 
                                            type="text" 
                                            value={diceExpression}
                                            onChange={(e) => setDiceExpression(e.target.value)}
                                            className="w-24 p-1 text-sm rounded bg-gray-700 border border-gray-600 text-white"
                                            placeholder="1d20"
                                        />
                                        <button 
                                            onClick={handleRollDice}
                                            className="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded text-sm font-bold"
                                        >
                                            Roll
                                        </button>
                                    </div>
                                    <div className="flex gap-1 justify-between">
                                        {["1d20", "2d6", "1d100"].map(exp => (
                                            <button 
                                                key={exp}
                                                onClick={() => setDiceExpression(exp)}
                                                className="text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 px-2 py-0.5 rounded"
                                            >
                                                {exp}
                                            </button>
                                        ))}
                                    </div>
                                    <button 
                                        onClick={() => setShowDice(false)}
                                        className="text-xs text-gray-500 hover:text-gray-300 self-end mt-1"
                                    >
                                        å…³é—­
                                    </button>
                                </div>
                            )}

                            {logs.map((log, i) => (
                                <div key={i} className={`p-2 rounded leading-relaxed ${
                                    log.type === 'narrative' ? 'bg-gray-800 text-yellow-100 border-l-2 border-yellow-600' :
                                    log.type === 'combat' ? 'bg-red-900/20 text-red-100 border-l-2 border-red-600' :
                                    log.type === 'action' ? 'bg-gray-700/50 text-gray-300 text-right italic' :
                                    log.type === 'success' ? 'bg-green-900/30 text-green-200 border-l-2 border-green-500' :
                                    log.type === 'danger' ? 'bg-red-600 text-white font-bold text-center' :
                                    'text-gray-300'
                                }`}>
                                    {log.text}
                                </div>
                            ))}
                            {processing && (
                                <div className="flex items-center gap-2 text-gray-400 italic p-2">
                                    <span className="animate-spin">âœ¦</span> AI æ­£åœ¨ç”Ÿæˆ...
                                </div>
                            )}
                        </div>

                        {/* Input / Controls Area */}
                        <div className="bg-gray-800 p-4 rounded border border-gray-600 shadow-lg z-10">
                            {phase === 'adventure' ? (
                                // Adventure Controls
                                <div className="flex gap-2">
                                    <button
                                        onClick={() => setShowDice(!showDice)}
                                        className={`px-3 rounded border ${showDice ? 'bg-purple-700 border-purple-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                        title="æ‰“å¼€æ·éª°å™¨"
                                    >
                                        ğŸ²
                                    </button>
                                    <input
                                        type="text"
                                        value={inputAction}
                                        onChange={(e) => setInputAction(e.target.value)}
                                        onKeyDown={(e) => e.key === 'Enter' && handleAdventureAction()}
                                        placeholder="è¾“å…¥ä½ çš„è¡ŒåŠ¨ (ä¾‹å¦‚: å‘åŒ—æ¢ç´¢ï¼Œå¯»æ‰¾æ°´æºï¼Œè°ƒæŸ¥ç¥åº™...)"
                                        className="flex-1 p-3 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                        disabled={processing}
                                    />
                                    <button
                                        onClick={handleAdventureAction}
                                        disabled={processing || !inputAction.trim()}
                                        className="px-6 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded shadow disabled:opacity-50"
                                    >
                                        è¡ŒåŠ¨
                                    </button>
                                </div>
                            ) : (
                                // Combat Controls
                                <div className="space-y-3">
                                    <div className="flex justify-between items-center text-xs text-gray-400 uppercase tracking-wider">
                                        <span>æˆ˜æ–—æ¨¡å¼ - é€‰æ‹©æŠ€èƒ½æˆ–è¾“å…¥ç‰¹æ®Šè¡ŒåŠ¨</span>
                                        <button 
                                            onClick={() => setShowDice(!showDice)}
                                            className="text-purple-400 hover:text-purple-300 flex items-center gap-1"
                                        >
                                            <span>ğŸ² æ·éª°å™¨</span>
                                        </button>
                                        <span>å½“å‰ç›®æ ‡: {enemies[selectedTargetIndex]?.name || "æ— "}</span>
                                    </div>
                                    
                                    {/* Skills */}
                                    <div className="flex flex-col gap-2">
                                        {/* Active Skills */}
                                        <div className="flex gap-2 flex-wrap">
                                            {player.skills.filter(s => s.type !== 'passive').map((skill, i) => (
                                                <button
                                                    key={i}
                                                    onClick={() => handleCombatAction('skill', skill)}
                                                    disabled={processing || player.stats.hp <= 0}
                                                    className="flex flex-col items-start px-3 py-2 bg-red-700 hover:bg-red-600 text-white rounded shadow border-b-4 border-red-900 active:border-0 active:translate-y-1 disabled:opacity-50 disabled:translate-y-0 disabled:border-b-4 min-w-[120px]"
                                                    title={skill.description}
                                                >
                                                    <span className="font-bold text-sm">{skill.name}</span>
                                                    <div className="flex gap-1 text-[10px] opacity-80 mt-1">
                                                        {skill.cost > 0 && <span>{skill.cost}{skill.costType}</span>}
                                                        {skill.target && <span className="bg-black/30 px-1 rounded">{skill.target === 'aoe' ? 'èŒƒå›´' : skill.target === 'self' ? 'è‡ªèº«' : 'å•ä½“'}</span>}
                                                    </div>
                                                </button>
                                            ))}
                                        </div>
                                        
                                        {/* Passive Skills */}
                                        {player.skills.some(s => s.type === 'passive') && (
                                            <div className="bg-gray-700/50 p-2 rounded border border-gray-600 flex flex-wrap gap-2">
                                                <span className="text-xs text-gray-400 uppercase font-bold">è¢«åŠ¨æŠ€èƒ½:</span>
                                                {player.skills.filter(s => s.type === 'passive').map((skill, i) => (
                                                    <div key={i} className="text-xs bg-gray-800 px-2 py-1 rounded text-gray-300 border border-gray-700" title={skill.description}>
                                                        {skill.name}
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>

                                    {/* Custom Combat Action */}
                                    <div className="flex gap-2">
                                        <input
                                            type="text"
                                            value={inputAction}
                                            onChange={(e) => setInputAction(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && handleCombatAction('custom')}
                                            placeholder="å°è¯•ç‰¹æ®Šæˆ˜æ–—è¡ŒåŠ¨ (ä¾‹å¦‚: å¯»æ‰¾æ©ä½“ï¼ŒæŠ•æ·æ²™çŸ³...)"
                                            className="flex-1 p-2 rounded bg-gray-700 border border-gray-600 focus:border-red-500 focus:outline-none text-white text-sm"
                                            disabled={processing}
                                        />
                                        <button
                                            onClick={() => handleCombatAction('custom')}
                                            disabled={processing || !inputAction.trim()}
                                            className="px-4 bg-gray-600 hover:bg-gray-500 text-white text-sm font-bold rounded disabled:opacity-50"
                                        >
                                            æ‰§è¡Œ
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        function App() {
            const [gameConfig, setGameConfig] = useState(null);
            const [character, setCharacter] = useState(null);

            const handleConnect = (config) => {
                setGameConfig(config);
            };

            if (!gameConfig) {
                return <ConfigScreen onConnect={handleConnect} />;
            }

            return (
                <>
                    {!character ? (
                        <CharacterCreation onCharacterCreated={setCharacter} config={gameConfig} />
                    ) : (
                        <GameInterface character={character} config={gameConfig} />
                    )}
                </>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
