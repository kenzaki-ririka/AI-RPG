<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI RPG Game (Multi-Model)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; 
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; 
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        const { useState, useEffect, useRef } = React;

        // --- Configuration & Models ---

        const PROVIDERS = {
            GOOGLE: "google",
            OPENAI: "openai",
            DEEPSEEK: "deepseek",
            ANTHROPIC: "anthropic"
        };

        const AVAILABLE_MODELS = [
            // Google Models
            { id: "gemini-3-pro-preview", name: "Gemini 3.0 Pro Preview (Paid)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-2.5-pro", name: "Gemini 2.5 Pro (Thinking Model)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-2.0-pro-exp", name: "Gemini 2.0 Pro Exp (If Available)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-1.5-pro", name: "Gemini 1.5 Pro (Free Tier)", provider: PROVIDERS.GOOGLE },
            { id: "gemini-1.5-flash", name: "Gemini 1.5 Flash (Fast)", provider: PROVIDERS.GOOGLE },
            // DeepSeek Models
            { id: "deepseek-chat", name: "DeepSeek V3 (Chat)", provider: PROVIDERS.DEEPSEEK },
            { id: "deepseek-reasoner", name: "DeepSeek R1 (Reasoner)", provider: PROVIDERS.DEEPSEEK },
            // Anthropic Models (Simulated Date: Nov 2025)
            { id: "claude-3-7-sonnet-20250219", name: "Claude 3.7 Sonnet (Latest)", provider: PROVIDERS.ANTHROPIC },
            { id: "claude-3-5-sonnet-20241022", name: "Claude 3.5 Sonnet", provider: PROVIDERS.ANTHROPIC },
            { id: "claude-3-opus-20240229", name: "Claude 3 Opus", provider: PROVIDERS.ANTHROPIC },
            // OpenAI / Compatible Models
            { id: "gpt-4o", name: "GPT-4o", provider: PROVIDERS.OPENAI },
            { id: "gpt-4-turbo", name: "GPT-4 Turbo", provider: PROVIDERS.OPENAI },
            { id: "gpt-3.5-turbo", name: "GPT-3.5 Turbo", provider: PROVIDERS.OPENAI },
            { id: "custom", name: "Custom Model ID", provider: PROVIDERS.OPENAI }
        ];

        const DEFAULT_CONFIG = {
            provider: PROVIDERS.GOOGLE,
            model: "gemini-2.5-pro",
            baseUrl: "https://generativelanguage.googleapis.com", // Default Google URL
            apiKey: ""
        };

        // --- AI Service Implementation ---

        const callAI = async (config, messages, jsonMode = true) => {
            const { provider, model, baseUrl, apiKey } = config;

            try {
                if (provider === PROVIDERS.GOOGLE) {
                    // --- Google Gemini API ---
                    let promptText = "";
                    messages.forEach(msg => {
                        promptText += `${msg.role === 'system' ? 'System Instruction' : 'User Input'}: ${msg.content}\n\n`;
                    });

                    // Use configured baseUrl (allows proxy usage)
                    // Ensure no trailing slash
                    const cleanBaseUrl = (baseUrl || "https://generativelanguage.googleapis.com").replace(/\/$/, "");
                    const url = `${cleanBaseUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`;

                    const response = await fetch(url, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: promptText }] }],
                            generationConfig: {
                                responseMimeType: jsonMode ? "application/json" : "text/plain"
                            }
                        })
                    });

                    if (!response.ok) {
                        const err = await response.json().catch(() => ({}));
                        throw new Error(err.error?.message || `Google API Error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    if (!data.candidates || data.candidates.length === 0) throw new Error("No content generated");
                    const content = data.candidates[0].content.parts[0].text;
                    return jsonMode ? JSON.parse(content) : content;

                } else if (provider === PROVIDERS.ANTHROPIC) {
                    // --- Anthropic API ---
                    let url = baseUrl.replace(/\/$/, "");
                    if (!url.endsWith("/v1/messages")) {
                        url += "/v1/messages";
                    }

                    const systemMessage = messages.find(m => m.role === 'system')?.content || "";
                    const userMessages = messages.filter(m => m.role !== 'system').map(m => ({
                        role: m.role,
                        content: m.content
                    }));

                    const body = {
                        model: model,
                        max_tokens: 4096,
                        system: systemMessage,
                        messages: userMessages,
                        temperature: 0.7
                    };

                    // Note: Anthropic API requires CORS proxy or browser-specific handling
                    const response = await fetch(url, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "x-api-key": apiKey,
                            "anthropic-version": "2023-06-01",
                            "anthropic-dangerous-direct-browser-access": "true"
                        },
                        body: JSON.stringify(body)
                    });

                    if (!response.ok) {
                        const err = await response.json().catch(() => ({}));
                        throw new Error(err.error?.message || `Anthropic API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    const textBlock = data.content.find(b => b.type === 'text');
                    if (!textBlock) throw new Error("No text content in Anthropic response");
                    
                    const content = textBlock.text;
                    if (jsonMode) {
                        // Try to find JSON block
                        const jsonMatch = content.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            return JSON.parse(jsonMatch[0]);
                        }
                        return JSON.parse(content);
                    }
                    return content;

                } else {
                    // --- OpenAI Compatible API (DeepSeek / OpenAI) ---
                    let url = baseUrl.replace(/\/$/, "");
                    if (!url.endsWith("/chat/completions")) {
                        url += "/chat/completions";
                    }

                    const body = {
                        model: model === 'custom' ? 'gpt-3.5-turbo' : model, 
                        messages: messages,
                        temperature: 0.7,
                        response_format: jsonMode ? { type: "json_object" } : undefined
                    };

                    const response = await fetch(url, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(body)
                    });

                    if (!response.ok) {
                        const err = await response.json().catch(() => ({}));
                        throw new Error(err.error?.message || `API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    const content = data.choices[0].message.content;
                    return jsonMode ? JSON.parse(content) : content;
                }
            } catch (error) {
                console.error("AI Service Error:", error);
                throw error;
            }
        };

        // --- Prompts (Unchanged) ---

        const getCharGenPrompt = (worldview, description) => {
            return [
                {
                    role: "system",
                    content: `ä½ æ˜¯ä¸€ä½å¯Œæœ‰åˆ›é€ åŠ›çš„ RPG æ¸¸æˆä¸»æŒäºº (GM)ã€‚è¯·æ ¹æ®ç”¨æˆ·çš„è¾“å…¥åˆ›å»ºä¸€ä¸ªè§’è‰²ã€‚
                    é‡è¦æç¤ºï¼šæ‰€æœ‰é¢å‘ç”¨æˆ·çš„æ–‡æœ¬ï¼ˆå§“åã€èŒä¸šã€æŠ€èƒ½æè¿°ã€æ•…äº‹ï¼‰å¿…é¡»ä½¿ç”¨ç®€ä½“ä¸­æ–‡ã€‚
                    
                    ä»…è¿”å›ç¬¦åˆæ­¤ç»“æ„çš„æœ‰æ•ˆ JSONï¼š
                    {
                        "name": "string (ä¸­æ–‡å)",
                        "class": "string (ä¸­æ–‡èŒä¸šå)",
                        "stats": { 
                            "hp": number (50-1000), 
                            "maxHp": number (åŒ hp), 
                            "mp": number (0-1000), 
                            "maxMp": number (åŒ mp),
                            "stamina": number (0-100),
                            "maxStamina": number (åŒ stamina),
                            "attack": number (10-100), 
                            "defense": number (0-50), 
                            "speed": number (5-50) 
                            // æ ¹æ®æè¿°æ·»åŠ å…¶ä»–ç›¸å…³å±æ€§
                        },
                        "skills": [
                            { 
                                "name": "string (ä¸­æ–‡æŠ€èƒ½å)", 
                                "type": "active"|"passive", 
                                "damage": number (0-100, è¢«åŠ¨/å¢ç›ŠæŠ€èƒ½ä¸º0), 
                                "cost": number (0-50), 
                                "costType": "mp"|"stamina"|"energy"|"none", 
                                "target": "single"|"aoe"|"self"|"all_enemies", 
                                "statusEffects": ["string (å¦‚ 'burn', 'freeze', 'poison', 'stun', 'disarm', 'bind')"],
                                "description": "string (ä¸­æ–‡æè¿°)" 
                            }
                        ],
                        "items": [
                            { "name": "string (ä¸­æ–‡ç‰©å“å)", "type": "consumable"|"equipment"|"material", "effect": { "hp": number, "mp": number }, "count": number, "description": "string" }
                        ],
                        "story": "string (ä¸°å¯Œçš„ä¸­æ–‡èƒŒæ™¯æ•…äº‹)"
                    }
                    
                    æŒ‡å¯¼æ–¹é’ˆï¼š
                    - æ ¹æ®èŒä¸šå¤æ‚ç¨‹åº¦åˆ›å»º 3 åˆ° 10 ä¸ªæŠ€èƒ½ã€‚
                    - åŒ…å«å¤šæ ·åŒ–çš„æœºåˆ¶ï¼šä¼¤å®³ã€æ²»ç–—ã€å¢ç›Š (Buffs)ã€å‡ç›Š (Debuffs)ã€‚
                    - å¦‚æœåˆé€‚ï¼ŒåŒ…å« 1-2 ä¸ªè¢«åŠ¨æŠ€èƒ½ã€‚
                    - ç»™è§’è‰² 3-5 ä¸ªåˆå§‹ç‰©å“ï¼ˆä¾‹å¦‚ï¼šç”Ÿå‘½è¯æ°´ã€å£ç²®ã€åœ°å›¾ã€æ­¦å™¨ï¼‰ã€‚
                    - ç¡®ä¿èµ„æºæ¶ˆè€—ä¸æä¾›çš„å±æ€§ç›¸åŒ¹é…ã€‚`
                },
                {
                    role: "user",
                    content: `ä¸–ç•Œè®¾å®š: ${worldview}\nè§’è‰²æè¿°: ${description}`
                }
            ];
        };

        // --- Unified Game Prompt ---
        const getGamePrompt = (player, enemies, history, phase, actionData, showNarrative, combatReport = null) => {
            // 1. Construct Chat History
            const chatHistory = history
                .filter(log => log.type === 'narrative' || log.type === 'combat' || log.type === 'action')
                .map(log => {
                    // Combine narrative and combat logs into 'model' role
                    if (log.type === 'narrative' || log.type === 'combat') {
                        return { role: "model", content: log.text };
                    } else {
                        // User action
                        const cleanText = log.text.startsWith("> ") ? log.text.substring(2) : log.text;
                        return { role: "user", content: cleanText };
                    }
                });

            // 2. Construct System Context
            const enemyState = enemies.length > 0 
                ? enemies.map((e, i) => `[${i}] ${e.name} (HP ${e.stats.hp}/${e.stats.maxHp}, ç‰¹æ€§: ${e.traits ? e.traits.map(t => t.name).join(",") : "æ— "})`).join("\n")
                : "å½“å‰æ— æ•Œäºº";

            const playerSkills = player.skills.map(s => `${s.name} (${s.type}, ${s.cost}${s.costType})`).join(", ");
            const playerBuffs = player.buffs ? JSON.stringify(player.buffs) : "æ— ";

            const systemInstruction = {
                role: "system",
                content: `ä½ æ˜¯ä¸€ä½RPG æ¸¸æˆä¸»æŒäºº (Game Master)ã€‚ä½ è´Ÿè´£ä¸»æŒæ¸¸æˆï¼ŒåŒ…æ‹¬å‰§æƒ…æ¢ç´¢å’Œæˆ˜æ–—ç»“ç®—ã€‚
                
                ã€å½“å‰ä¸–ç•Œä¸è§’è‰²ã€‘
                ä¸–ç•Œè®¾å®š: ${player.worldview || "æœªçŸ¥"}
                å½“å‰ç©å®¶: ${player.name} (${player.class}).
                èƒŒæ™¯æ•…äº‹: ${player.description || "æœªçŸ¥"}
                å±æ€§: ${JSON.stringify(player.stats)}.
                æŠ€èƒ½: ${playerSkills}
                Buffs: ${playerBuffs}
                ç‰©å“æ : ${JSON.stringify(player.items || [])}.
                
                ã€å½“å‰çŠ¶æ€ã€‘
                æ¨¡å¼: ${phase === 'combat' ? 'âš”ï¸ æˆ˜æ–—æ¨¡å¼' : 'ğŸŒ æ¢ç´¢æ¨¡å¼'}
                ${phase === 'combat' ? `æ•Œäººåˆ—è¡¨:\n${enemyState}` : ''}
                ${combatReport ? `\nã€ç³»ç»Ÿæˆ˜æŠ¥ (å·²å‘ç”Ÿçš„æ•°å€¼ç»“æœ)ã€‘\n${combatReport}\n(è¯·æ ¹æ®ä¸Šè¿°ç³»ç»Ÿæˆ˜æŠ¥ç”Ÿæˆå‰§æƒ…æè¿°ï¼Œä¸è¦é‡æ–°è®¡ç®—æ•°å€¼)` : ''}
                
                ã€ä½ çš„ä»»åŠ¡ã€‘
                æ ¹æ®ç”¨æˆ·çš„è¡ŒåŠ¨å’Œå½“å‰çŠ¶æ€ï¼Œç”Ÿæˆä¸‹ä¸€é˜¶æ®µçš„å‰§æƒ…æˆ–æˆ˜æ–—ç»“æœã€‚
                å¿…é¡»ä¿æŒä¸Šä¸‹æ–‡è¿è´¯æ€§ã€‚è®°å¾—ä¹‹å‰çš„å‰§æƒ…å’ŒçŠ¶æ€ã€‚
                ${combatReport ? 'æ³¨æ„ï¼šæ•°å€¼ç»“æœå·²ç”±ç³»ç»Ÿå†³å®šï¼Œä½ åªéœ€è´Ÿè´£æè¿°ç”»é¢ã€‚' : 'ä»»åŠ¡ï¼š1. è®¡ç®—ä¼¤å®³ä¸ç»“æœã€‚ 2. ç®¡ç†çŠ¶æ€ã€‚'}
                
                ${phase === 'combat' && !showNarrative ? 'è¯·æä¾›ç®€çŸ­çš„æˆ˜æ–—æ€»ç»“ã€‚' : 'è¯·ä»¥ä¸°å¯Œã€å¼•äººå…¥èƒœçš„å°è¯´é£æ ¼æè¿°ç»“æœ (ç®€ä½“ä¸­æ–‡)ã€‚'}

                ã€JSON è¿”å›æ ¼å¼ã€‘
                ä»…è¿”å›ç¬¦åˆæ­¤ç»“æ„çš„æœ‰æ•ˆ JSONã€‚**ä»…åŒ…å«æœ‰å˜åŒ–çš„å­—æ®µï¼Œæ— å˜åŒ–åˆ™çœç•¥ã€‚å¯åªåŒ…å«narrative**

                {
                    "narrative": "string (å¿…é¡»åŒ…å«)",
                    
                    // --- çŠ¶æ€æ›´æ–° (é€šç”¨) ---
                    "statChanges": { "hp": number, "mp": number, ... }, 
                    "newItems": [ { "name": "string", "type": "string", "count": number, ... } ],
                    "removedItems": ["string"],
                    "newSkills": [ { "name": "string", "type": "active"|"passive", "damage": number, "cost": number, ... } ],
                    "updatedSkills": [ ... ],
                    "removedSkills": ["string"],
                    "buffsAdded": [ { "name": "string", "effect": "string", "duration": number, "description": "string", "type": "buff"|"debuff" } ],
                    "buffsRemoved": ["string"],

                    // --- æˆ˜æ–—/ä¸–ç•Œæ›´æ–° ---
                    "newEnemies": [ // ä»…åœ¨è§¦å‘æ–°æˆ˜æ–—æ—¶
                        { 
                            "name": "string", 
                            "stats": { "hp": number, "maxHp": number, "attack": number, "defense": number, "speed": number },
                            "skills": ["string"],
                            "traits": [ { "name": "string", "effect": "string", "description": "string" } ],
                            "description": "string"
                        }
                    ],
                    "enemiesUpdates": [ // ä»…åœ¨æˆ˜æ–—ä¸­æ•ŒäººçŠ¶æ€å˜åŒ–æ—¶
                        { 
                            "index": number, 
                            "damageTaken": number, 
                            "hpChange": number, 
                            "statusAdded": "string",
                            "statusRemoved": "string"
                        }
                    ],
                    "enemyBuffsAdded": [
                         { "enemyIndex": number, "buff": { "name": "string", "description": "string", "duration": number } }
                    ]
                }
                `
            };

            // 3. Construct Current User Message
            let userContent = "";
            if (phase === 'combat') {
                userContent = `ã€æˆ˜æ–—å›åˆã€‘\nç©å®¶è¡ŒåŠ¨: ${JSON.stringify(actionData)}`;
            } else {
                userContent = `ã€æ¢ç´¢è¡ŒåŠ¨ã€‘\nç©å®¶: ${actionData}`;
            }

            const latestUserMessage = {
                role: "user",
                content: userContent
            };

            return [systemInstruction, ...chatHistory, latestUserMessage];
        };

        // --- Helper Functions ---
        
        const rollDice = (expression) => {
            try {
                // Simple parser for XdY+Z format
                const regex = /^(\d+)d(\d+)(?:\+([-]?\d+))?$/i;
                const match = expression.trim().match(regex);
                
                if (!match) {
                    // Try parsing just a number
                    const num = parseInt(expression);
                    if (!isNaN(num)) return { total: num, details: `${num}`, expression };
                    throw new Error("æ— æ•ˆçš„è¡¨è¾¾å¼ã€‚æ ¼å¼ç¤ºä¾‹: 2d6, 1d20+5");
                }

                const count = parseInt(match[1]);
                const sides = parseInt(match[2]);
                const modifier = match[3] ? parseInt(match[3]) : 0;

                if (count > 100) throw new Error("éª°å­æ•°é‡è¿‡å¤š");
                if (sides > 1000) throw new Error("éª°å­é¢æ•°è¿‡å¤š");

                let total = 0;
                const rolls = [];
                for (let i = 0; i < count; i++) {
                    const roll = Math.floor(Math.random() * sides) + 1;
                    rolls.push(roll);
                    total += roll;
                }
                total += modifier;

                const details = `[${rolls.join(",")}]${modifier !== 0 ? (modifier > 0 ? `+${modifier}` : modifier) : ""} = ${total}`;
                return { total, details, expression };
            } catch (e) {
                return { error: e.message };
            }
        };

        // --- Components ---

        function ConfigScreen({ onConnect }) {
            const [config, setConfig] = useState(() => {
                const saved = localStorage.getItem("ai_rpg_config");
                return saved ? JSON.parse(saved) : DEFAULT_CONFIG;
            });
            
            const [customModel, setCustomModel] = useState("");

            useEffect(() => {
                localStorage.setItem("ai_rpg_config", JSON.stringify(config));
            }, [config]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (config.apiKey.trim().length > 0) {
                    const finalConfig = { ...config };
                    if (config.model === 'custom') {
                        finalConfig.model = customModel;
                    }
                    onConnect(finalConfig);
                }
            };

            const handleProviderChange = (newProvider) => {
                let newBaseUrl = "";
                if (newProvider === PROVIDERS.GOOGLE) newBaseUrl = "https://generativelanguage.googleapis.com";
                else if (newProvider === PROVIDERS.DEEPSEEK) newBaseUrl = "https://api.deepseek.com";
                else if (newProvider === PROVIDERS.ANTHROPIC) newBaseUrl = "https://api.anthropic.com";
                else newBaseUrl = "https://api.openai.com/v1";

                setConfig(prev => ({
                    ...prev,
                    provider: newProvider,
                    // Default to first model of that provider
                    model: AVAILABLE_MODELS.find(m => m.provider === newProvider)?.id || 'custom',
                    baseUrl: newBaseUrl
                }));
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-900 text-gray-200">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-lg max-w-md w-full border border-gray-700 space-y-6">
                        <div>
                            <h1 className="text-2xl font-bold text-center text-purple-400">æ¸¸æˆè®¾ç½® (Game Config)</h1>
                            <p className="text-center text-xs text-gray-500 mt-1">é€‰æ‹©ä½ çš„ AI å¼•æ“</p>
                        </div>

                        <form onSubmit={handleSubmit} className="space-y-4">
                            {/* Provider Selection */}
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-400">AI æä¾›å•† (Provider)</label>
                                <div className="flex gap-2 flex-wrap">
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.GOOGLE)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.GOOGLE ? 'bg-purple-600 border-purple-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        Google
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.DEEPSEEK)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.DEEPSEEK ? 'bg-blue-600 border-blue-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        DeepSeek
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.ANTHROPIC)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.ANTHROPIC ? 'bg-orange-600 border-orange-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        Claude
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => handleProviderChange(PROVIDERS.OPENAI)}
                                        className={`flex-1 py-2 px-2 rounded border text-xs md:text-sm ${config.provider === PROVIDERS.OPENAI ? 'bg-green-600 border-green-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                    >
                                        OpenAI
                                    </button>
                                </div>
                            </div>

                            {/* Model Selection */}
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-400">æ¨¡å‹ (Model)</label>
                                <select
                                    value={config.model}
                                    onChange={(e) => setConfig({...config, model: e.target.value})}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                >
                                    {AVAILABLE_MODELS.filter(m => m.provider === config.provider).map(m => (
                                        <option key={m.id} value={m.id}>{m.name}</option>
                                    ))}
                                    {config.provider === PROVIDERS.OPENAI && <option value="custom">è‡ªå®šä¹‰ / å…¶ä»–...</option>}
                                </select>
                            </div>

                            {/* Custom Model Input (Only if custom selected) */}
                            {config.model === 'custom' && (
                                <div>
                                    <label className="block text-sm font-medium mb-1 text-gray-400">è‡ªå®šä¹‰æ¨¡å‹ ID</label>
                                    <input
                                        type="text"
                                        value={customModel}
                                        onChange={(e) => setCustomModel(e.target.value)}
                                        className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                        placeholder="ä¾‹å¦‚ï¼šclaude-3-opus..."
                                        required
                                    />
                                </div>
                            )}

                            {/* API Key */}
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-400">API å¯†é’¥ (Key)</label>
                                <input 
                                    type="password" 
                                    value={config.apiKey}
                                    onChange={(e) => setConfig({...config, apiKey: e.target.value})}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                    placeholder={
                                        config.provider === PROVIDERS.GOOGLE ? "AIza..." : 
                                        config.provider === PROVIDERS.ANTHROPIC ? "sk-ant-..." :
                                        "sk-..."
                                    }
                                    required
                                />
                                {config.provider === PROVIDERS.ANTHROPIC && (
                                    <p className="text-[10px] text-orange-400 mt-1">
                                        æ³¨æ„: ç›´æ¥åœ¨æµè§ˆå™¨ä½¿ç”¨ Anthropic Key å¯èƒ½ä¼šå› ä¸º CORS å¤±è´¥ã€‚å»ºè®®ä½¿ç”¨è½¬å‘ä»£ç†åœ°å€ (Base URL)ã€‚
                                    </p>
                                )}
                            </div>

                            <button 
                                type="submit" 
                                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-200 mt-4"
                            >
                                è¿æ¥å¹¶å¼€å§‹ (Connect)
                            </button>
                        </form>
                    </div>
                </div>
            );
        }

        function CharacterCreation({ onCharacterCreated, config }) {
            const [worldview, setWorldview] = useState("èµ›åšæœ‹å…‹");
            const [description, setDescription] = useState("ä¸€ä¸ªæ‹¥æœ‰æœºæ¢°è‡‚çš„æµæµªé»‘å®¢ã€‚");
            const [loading, setLoading] = useState(false);

            const handleSubmit = async (e) => {
                e.preventDefault();
                setLoading(true);
                try {
                    const messages = getCharGenPrompt(worldview, description);
                    const charData = await callAI(config, messages);
                    // Attach world settings to character data for future reference
                    charData.worldview = worldview;
                    charData.description = description;
                    onCharacterCreated(charData);
                } catch (error) {
                    alert("ç”Ÿæˆè§’è‰²å¤±è´¥: " + error.message);
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-4">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-lg max-w-md w-full border border-gray-700">
                        <h1 className="text-3xl font-bold mb-6 text-center text-purple-400">AI RPG ç”Ÿæˆå™¨</h1>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-300">ä¸–ç•Œè§‚è®¾å®š</label>
                                <input 
                                    type="text" 
                                    value={worldview}
                                    onChange={(e) => setWorldview(e.target.value)}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                    placeholder="ä¾‹å¦‚ï¼šèµ›åšæœ‹å…‹ 2077ï¼Œé«˜é­”å¥‡å¹»..."
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-1 text-gray-300">è§’è‰²æè¿°</label>
                                <textarea 
                                    value={description}
                                    onChange={(e) => setDescription(e.target.value)}
                                    className="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white h-32"
                                    placeholder="æè¿°ä½ çš„è‹±é›„..."
                                />
                            </div>
                            <button 
                                type="submit" 
                                disabled={loading}
                                className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition duration-200 disabled:opacity-50 flex justify-center items-center gap-2"
                            >
                                {loading ? "æ­£åœ¨æ„æ€..." : "å¼€å§‹å†’é™©"}
                            </button>
                        </form>
                        <div className="text-center mt-4 text-xs text-gray-500">
                            è¿è¡Œæ¨¡å‹ï¼š{config.model}
                        </div>
                    </div>
                </div>
            );
        }

        function GameInterface({ character, config }) {
            const [player, setPlayer] = useState(character);
            // Phase: 'adventure' (Exploration) or 'combat'
            const [phase, setPhase] = useState('adventure'); 
            
            const [enemies, setEnemies] = useState([]);
            const [selectedTargetIndex, setSelectedTargetIndex] = useState(0);
            
            const [logs, setLogs] = useState([
                { text: character.story, type: 'narrative' },
                { text: "å†’é™©å¼€å§‹äº†ã€‚ä½ å¯ä»¥è¾“å…¥è¡ŒåŠ¨æ¥æ¢ç´¢è¿™ä¸ªä¸–ç•Œã€‚", type: 'narrative' }
            ]);
            
            const [inputAction, setInputAction] = useState("");
            const [processing, setProcessing] = useState(false);
            const [showDice, setShowDice] = useState(false);
            const [diceExpression, setDiceExpression] = useState("1d20");
            const [showInventory, setShowInventory] = useState(false);
            const [showNarrative, setShowNarrative] = useState(true); 
            const [useJsCombat, setUseJsCombat] = useState(false); // New Toggle for JS Combat

            const logContainerRef = useRef(null);
            const fileInputRef = useRef(null);

            // --- Export / Import Handlers ---
            const handleExport = () => {
                const gameState = {
                    player,
                    phase,
                    enemies,
                    selectedTargetIndex,
                    logs,
                    timestamp: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(gameState, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai-rpg-save-${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const handleImportClick = () => {
                fileInputRef.current.click();
            };

            const handleImportFile = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const gameState = JSON.parse(e.target.result);
                        // Basic validation
                        if (gameState.player && Array.isArray(gameState.logs)) {
                            setPlayer(gameState.player);
                            setPhase(gameState.phase || 'adventure');
                            setEnemies(gameState.enemies || []);
                            if (gameState.selectedTargetIndex !== undefined) setSelectedTargetIndex(gameState.selectedTargetIndex);
                            setLogs(gameState.logs);
                            // Add a system log to indicate success (without adding to history for export potentially, but useful for user)
                            // We actually replace logs, so we should probably append this success message to the loaded logs 
                            // OR just rely on the state update. But appending is nicer.
                            // However, since logs is state, we can't easily append *after* setLogs in the same tick reliably for display if we just replaced it.
                            // But we can append to the array before setting.
                            const newLogs = [...gameState.logs, { text: "âœ… å­˜æ¡£/è®°å½•å·²æˆåŠŸå¯¼å…¥ï¼", type: "success" }];
                            setLogs(newLogs);
                        } else {
                            throw new Error("æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘å¿…è¦æ•°æ®");
                        }
                    } catch (err) {
                        alert("å¯¼å…¥å¤±è´¥: " + err.message);
                    }
                };
                reader.readAsText(file);
                event.target.value = ''; // Reset
            };

            useEffect(() => {
                if (logContainerRef.current) {
                    logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
                }
            }, [logs]);

            const addLog = (text, type = 'neutral') => {
                setLogs(prev => [...prev, { text, type }]);
            };

            const handleRollDice = (e) => {
                e.preventDefault(); // Prevent form submission if inside a form
                const result = rollDice(diceExpression);
                if (result.error) {
                    addLog(`ğŸ² æ·éª°é”™è¯¯: ${result.error}`, 'danger');
                } else {
                    const rollText = `(ğŸ² ${result.expression}: ${result.details})`;
                    setInputAction(prev => (prev ? prev + " " + rollText : rollText));
                    addLog(`ğŸ² æ·éª°æ£€å®š: ${result.expression} => ${result.details}`, 'action');
                    setShowDice(false);
                }
            };

            const handleUseItem = (itemIndex) => {
                const item = player.items[itemIndex];
                if (!item) return;

                // Apply effects if consumable
                if (item.type === 'consumable' && item.effect) {
                    setPlayer(prev => {
                        const newStats = { ...prev.stats };
                        Object.entries(item.effect).forEach(([key, value]) => {
                            if (typeof newStats[key] !== 'undefined') {
                                const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                                newStats[key] = newStats[key] + value;
                                if (typeof newStats[maxKey] !== 'undefined') {
                                    newStats[key] = Math.min(newStats[key], newStats[maxKey]);
                                }
                            }
                        });
                        
                        // Decrease count or remove
                        const newItems = [...prev.items];
                        newItems[itemIndex].count--;
                        if (newItems[itemIndex].count <= 0) {
                            newItems.splice(itemIndex, 1);
                        }
                        
                        return { ...prev, stats: newStats, items: newItems };
                    });
                    addLog(`ä½¿ç”¨äº† ${item.name}`, 'success');
                    
                    // In combat, using an item might take a turn? 
                    // For now, let's assume it's a free action or part of the narrative action 
                    // But if in combat, we might want to trigger a turn update.
                    // Let's keep it simple: Using item from UI is "instant" but maybe we should tell AI?
                    // Ideally, using item should be an action sent to AI.
                    // But for now, let's just update stats locally.
                } else {
                    addLog(`${item.name} æ— æ³•ç›´æ¥ä½¿ç”¨`, 'neutral');
                }
            };

            // --- JS Combat Logic ---
            const calculateDamage = (attacker, defender, skill = null) => {
                // Base stats
                const atk = attacker.stats.attack || 10;
                const def = defender.stats.defense || 0;
                const speed = attacker.stats.speed || 10;
                const targetSpeed = defender.stats.speed || 10;

                // Hit chance (simple logic)
                const hitChance = 0.9 + ((speed - targetSpeed) * 0.01);
                if (Math.random() > hitChance) return { damage: 0, type: 'miss' };

                // Crit chance
                const critChance = 0.05 + ((speed - targetSpeed) * 0.005);
                const isCrit = Math.random() < critChance;

                // Damage Calculation
                let rawDamage = atk;
                let multiplier = 1.0;

                if (skill) {
                    // Skill damage often replaces or adds to ATK. 
                    // Let's say skill.damage is a power value (e.g. 50 = 1.5x atk, or flat damage)
                    // For simplicity: if skill.damage > 0, we use it as base power scaling
                    if (skill.damage > 0) {
                        // Assume skill.damage 100 = 100% ATK. 50 = 50% ATK? 
                        // Or skill.damage is flat? Let's treat as flat + scaling
                        // Hybrid: Skill Dmg + (ATK * 0.5)
                        rawDamage = skill.damage + (atk * 0.5); 
                    }
                }

                // Defense mitigation (simple subtraction with min 1)
                let damage = Math.max(1, rawDamage - (def * 0.5));
                
                if (isCrit) {
                    damage *= 1.5;
                }

                return { 
                    damage: Math.floor(damage), 
                    type: isCrit ? 'crit' : 'hit',
                    isCrit 
                };
            };

            // --- Adventure Phase Handler (Unified) ---
            const handleAdventureAction = async () => {
                if (processing || !inputAction.trim()) return;
                const action = inputAction.trim();
                setInputAction("");
                setProcessing(true);
                addLog(`> ${action}`, 'action');

                try {
                    // Unified call: passing 'adventure' phase and empty enemy list (or current if any)
                    const messages = getGamePrompt(player, enemies, logs, 'adventure', action, showNarrative);
                    const result = await callAI(config, messages);
                    
                    // Handle the Unified Response
                    handleUnifiedResponse(result);

                } catch (error) {
                    addLog(`é”™è¯¯: ${error.message}`, 'danger');
                } finally {
                    setProcessing(false);
                }
            };

            // --- Combat Phase Handler (Unified) ---
            const handleCombatAction = async (actionType, skill = null) => {
                if (processing || player.stats.hp <= 0) return;
                
                // Construct action object (Skill or Custom Text)
                let actionObj = {};
                let tempPlayer = { ...player }; // Mutable copy for prompt generation

                if (skill) {
                    // 1. JS Logic: Check and Deduct Cost
                    if (skill.cost > 0) {
                        const costType = skill.costType ? skill.costType.toLowerCase() : 'mp';
                        let statKey = 'mp'; 
                        if (costType === 'stamina') statKey = 'stamina';
                        if (costType === 'energy') statKey = 'mp'; 

                        // Check if stat exists
                        if (player.stats[statKey] !== undefined) {
                            if (player.stats[statKey] < skill.cost) {
                                addLog(`âŒ ${statKey === 'mp' ? 'é­”æ³•å€¼' : 'ä½“åŠ›'}ä¸è¶³ (${player.stats[statKey]}/${skill.cost})ï¼Œæ— æ³•ä½¿ç”¨ ${skill.name}`, 'danger');
                                return;
                            }
                            // Deduct immediately for UI feedback
                            setPlayer(prev => ({
                                ...prev,
                                stats: {
                                    ...prev.stats,
                                    [statKey]: prev.stats[statKey] - skill.cost
                                }
                            }));
                            // Update tempPlayer for AI context so it knows current resources
                            tempPlayer.stats = { ...player.stats, [statKey]: player.stats[statKey] - skill.cost };
                        }
                    }

                    actionObj = { 
                        name: skill.name, 
                        type: skill.type, 
                        damage: skill.damage, 
                        cost: skill.cost,
                        target: skill.target,
                        effects: skill.statusEffects || []
                    };
                } else {
                    if (!inputAction.trim()) return;
                    actionObj = { name: inputAction.trim(), type: 'custom' };
                    setInputAction("");
                }

                setProcessing(true);
                addLog(`> ${actionObj.name} (ç›®æ ‡: ${enemies[selectedTargetIndex]?.name || 'æ— '})`, 'action');

                let combatReport = null;
                let jsStatUpdates = { player: {}, enemies: [] }; // Store JS updates to apply later or merge

                // --- JS Combat Execution ---
                if (useJsCombat && phase === 'combat' && enemies.length > 0) {
                    const targetIndex = selectedTargetIndex;
                    const target = enemies[targetIndex];
                    let reportLines = [];

                    // ... (calculation logic remains same) ...
                    // 1. Player Turn
                    if (target) {
                        const result = calculateDamage(player, target, skill);
                        if (result.type === 'miss') {
                            reportLines.push(`ä½ æ”»å‡» ${target.name}ï¼Œä½†æ˜¯æœªå‘½ä¸­ï¼`);
                        } else {
                            const critStr = result.isCrit ? " (æš´å‡»!)" : "";
                            reportLines.push(`ä½ å¯¹ ${target.name} é€ æˆäº† ${result.damage} ç‚¹ä¼¤å®³${critStr}ã€‚`);
                            jsStatUpdates.enemies.push({ index: targetIndex, hpChange: -result.damage });
                        }
                    }

                    // 2. Enemy Turn
                    enemies.forEach((e, idx) => {
                        let currentHp = e.stats.hp;
                        const pendingDmg = jsStatUpdates.enemies.find(u => u.index === idx)?.hpChange || 0;
                        if (currentHp + pendingDmg <= 0) {
                            reportLines.push(`${e.name} è¢«å‡»è´¥äº†ï¼`);
                            return; 
                        }

                        const eResult = calculateDamage(e, player, null); 
                        if (eResult.damage > 0) {
                             reportLines.push(`${e.name} æ”»å‡»ä½ ï¼Œé€ æˆäº† ${eResult.damage} ç‚¹ä¼¤å®³ã€‚`);
                             jsStatUpdates.player.hp = (jsStatUpdates.player.hp || 0) - eResult.damage;
                        } else {
                             reportLines.push(`${e.name} çš„æ”»å‡»æœªå‘½ä¸­ã€‚`);
                        }
                    });

                    combatReport = reportLines.join("\n");

                    // [OPTIMIZATION] If JS Combat AND No Narrative -> SKIP AI ENTIRELY
                    if (!showNarrative) {
                        // Construct a mock "AI Result" based purely on JS data
                        const mockResult = {
                            narrative: combatReport, // Use the report as narrative
                            playerStatChanges: jsStatUpdates.player,
                            enemiesUpdates: jsStatUpdates.enemies.map(u => ({
                                index: u.index,
                                hpChange: u.hpChange,
                                damageTaken: -u.hpChange
                            }))
                        };
                        
                        // Simulate delay slightly for UX or just run immediately
                        handleUnifiedResponse(mockResult);
                        setProcessing(false);
                        return; // EXIT FUNCTION, DO NOT CALL AI
                    }
                }

                try {
                    // Unified call
                    // Note: We pass tempPlayer to reflect cost deduction
                    const messages = getGamePrompt(tempPlayer, enemies, logs, 'combat', { ...actionObj, targetIndex: selectedTargetIndex }, showNarrative, combatReport);
                    const result = await callAI(config, messages);
                    
                    // If JS Combat, override AI's numeric updates with JS calculations to be safe
                    if (useJsCombat && combatReport) {
                        // Override Player HP change
                        if (!result.playerStatChanges) result.playerStatChanges = {};
                        if (jsStatUpdates.player.hp) {
                            result.playerStatChanges.hp = jsStatUpdates.player.hp;
                        }
                        
                        // Override Enemy Updates
                        if (jsStatUpdates.enemies.length > 0) {
                            result.enemiesUpdates = jsStatUpdates.enemies.map(u => ({
                                index: u.index,
                                hpChange: u.hpChange,
                                damageTaken: -u.hpChange
                            }));
                        }
                    }

                    handleUnifiedResponse(result);

                } catch (error) {
                    addLog(`é”™è¯¯: ${error.message}`, 'danger');
                } finally {
                    setProcessing(false);
                }
            };

            // --- Unified Response Handler ---
            const handleUnifiedResponse = (result) => {
                // 1. Narrative
                if (result.narrative) {
                    addLog(result.narrative, phase === 'combat' ? 'combat' : 'narrative');
                }

                // 2. Player Updates (Stats, Items, Skills, Buffs)
                setPlayer(prev => {
                    let newStats = { ...prev.stats };
                    let newItems = prev.items ? [...prev.items] : [];
                    let newSkillsList = prev.skills ? [...prev.skills] : [];
                    let newBuffs = prev.buffs ? [...prev.buffs] : [];

                    // Stats
                    if (result.statChanges) {
                        Object.entries(result.statChanges).forEach(([key, value]) => {
                            if (typeof newStats[key] !== 'undefined') {
                                newStats[key] += value;
                                const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                                if (typeof newStats[maxKey] !== 'undefined') {
                                    newStats[key] = Math.min(newStats[key], newStats[maxKey]);
                                }
                                newStats[key] = Math.max(0, newStats[key]);
                            }
                        });
                    }
                    // Also handle 'playerStatChanges' alias if AI uses old format occasionally
                    if (result.playerStatChanges) {
                         Object.entries(result.playerStatChanges).forEach(([key, value]) => {
                            if (typeof newStats[key] !== 'undefined') {
                                newStats[key] += value;
                                newStats[key] = Math.max(0, newStats[key]);
                            }
                        });
                    }

                    // Items
                    if (result.newItems) {
                        result.newItems.forEach(newItem => {
                            const existingItemIndex = newItems.findIndex(i => i.name === newItem.name);
                            if (existingItemIndex >= 0) {
                                newItems[existingItemIndex].count += newItem.count;
                            } else {
                                newItems.push(newItem);
                            }
                            addLog(`è·å¾—ç‰©å“: ${newItem.name} x${newItem.count}`, 'success');
                        });
                    }
                    if (result.removedItems) {
                        result.removedItems.forEach(remName => {
                            const idx = newItems.findIndex(i => i.name === remName);
                            if (idx >= 0) {
                                newItems[idx].count--;
                                if (newItems[idx].count <= 0) newItems.splice(idx, 1);
                            }
                        });
                    }

                    // Skills
                    if (result.newSkills) {
                        result.newSkills.forEach(skill => {
                            if (!newSkillsList.find(s => s.name === skill.name)) {
                                newSkillsList.push(skill);
                                addLog(`ğŸ’¡ ä¹ å¾—æ–°æŠ€èƒ½: ${skill.name}`, 'success');
                            }
                        });
                    }
                    if (result.updatedSkills) {
                         result.updatedSkills.forEach(skill => {
                            const idx = newSkillsList.findIndex(s => s.name === skill.name);
                            if (idx >= 0) {
                                newSkillsList[idx] = skill;
                                addLog(`ğŸ†™ æŠ€èƒ½å‡çº§: ${skill.name}`, 'success');
                            }
                        });
                    }
                    if (result.removedSkills) {
                        result.removedSkills.forEach(name => {
                            const idx = newSkillsList.findIndex(s => s.name === name);
                            if (idx >= 0) {
                                newSkillsList.splice(idx, 1);
                                addLog(`âŒ é—å¿˜æŠ€èƒ½: ${name}`, 'neutral');
                            }
                        });
                    }

                    // Buffs
                    if (result.buffsAdded) {
                        result.buffsAdded.forEach(buff => {
                            newBuffs.push(buff);
                            addLog(`ğŸ”¼ è·å¾—çŠ¶æ€: ${buff.name} (${buff.description})`, 'success');
                        });
                    }
                    // Alias for combat prompt
                    if (result.playerBuffsAdded) {
                        result.playerBuffsAdded.forEach(buff => {
                            newBuffs.push(buff);
                            addLog(`ğŸ”¼ è·å¾—çŠ¶æ€: ${buff.name} (${buff.description})`, 'success');
                        });
                    }

                    if (result.buffsRemoved) {
                        result.buffsRemoved.forEach(name => {
                            newBuffs = newBuffs.filter(b => b.name !== name);
                            addLog(`ğŸ”½ çŠ¶æ€æ¶ˆå¤±: ${name}`, 'neutral');
                        });
                    }
                     if (result.playerBuffsRemoved) {
                        result.playerBuffsRemoved.forEach(name => {
                            newBuffs = newBuffs.filter(b => b.name !== name);
                            addLog(`ğŸ”½ çŠ¶æ€æ¶ˆå¤±: ${name}`, 'neutral');
                        });
                    }

                    return { ...prev, stats: newStats, items: newItems, skills: newSkillsList, buffs: newBuffs };
                });

                // 3. World/Enemy Updates
                let currentEnemies = [...enemies];
                
                // New Enemies (Trigger Combat)
                if (result.newEnemies && result.newEnemies.length > 0) {
                    setEnemies(result.newEnemies);
                    setPhase('combat');
                    setSelectedTargetIndex(0);
                    addLog(`âš ï¸ é­é‡æ•Œè¢­ï¼å‡ºç° ${result.newEnemies.length} ä¸ªæ•Œäººï¼`, 'danger');
                    // Reset currentEnemies for further updates in this same tick (unlikely but safe)
                    currentEnemies = result.newEnemies;
                }

                // Existing Enemy Updates
                if (result.enemiesUpdates) {
                    result.enemiesUpdates.forEach(update => {
                        if (currentEnemies[update.index]) {
                            const e = currentEnemies[update.index];
                            
                            // Update HP
                            if (update.hpChange !== undefined) {
                                e.stats.hp = Math.max(0, Math.min(e.stats.maxHp, e.stats.hp + update.hpChange));
                            } else if (update.damageTaken !== undefined) {
                                e.stats.hp = Math.max(0, e.stats.hp - update.damageTaken);
                            }

                            // Handle Status
                            if (!e.buffs) e.buffs = [];
                            if (update.statusAdded && !e.buffs.find(b => b.name === update.statusAdded)) {
                                e.buffs.push({ name: update.statusAdded, duration: 3 });
                            }
                            if (update.statusRemoved) {
                                e.buffs = e.buffs.filter(b => b.name !== update.statusRemoved);
                            }
                        }
                    });
                }

                // Enemy Buffs
                if (result.enemyBuffsAdded) {
                     result.enemyBuffsAdded.forEach(item => {
                        if (currentEnemies[item.enemyIndex]) {
                            if (!currentEnemies[item.enemyIndex].buffs) currentEnemies[item.enemyIndex].buffs = [];
                            currentEnemies[item.enemyIndex].buffs.push(item.buff);
                        }
                    });
                }
                
                // 4. Check Deaths / Combat End
                // Use setEnemies to trigger re-render with updated state
                const aliveEnemies = currentEnemies.filter(e => e.stats.hp > 0);
                
                // Only update enemies list if we are in combat or just entered it
                if (phase === 'combat' || (result.newEnemies && result.newEnemies.length > 0)) {
                    setEnemies(aliveEnemies);
                    
                    if (aliveEnemies.length === 0 && phase === 'combat' && (!result.newEnemies || result.newEnemies.length === 0)) {
                         addLog("ğŸ† æˆ˜æ–—èƒœåˆ©ï¼", 'success');
                         // Clean up combat buffs
                         setPlayer(prev => ({
                            ...prev,
                            buffs: (prev.buffs || []).filter(b => b.duration === -1 || b.permanent) 
                        }));
                        setPhase('adventure');
                    }
                    
                    // Update target index
                    if (selectedTargetIndex >= aliveEnemies.length) {
                        setSelectedTargetIndex(Math.max(0, aliveEnemies.length - 1));
                    }
                }

                // Check Player Death
                // We need to check the *next* state of player, which we just scheduled via setPlayer.
                // Since we can't access it immediately, we approximate with result.statChanges
                // Or we can just trust the user will see 0 HP on next render. 
                // But let's add a log if it looks fatal.
                let hpChange = 0;
                if (result.statChanges?.hp) hpChange += result.statChanges.hp;
                if (result.playerStatChanges?.hp) hpChange += result.playerStatChanges.hp;
                
                if (player.stats.hp + hpChange <= 0) {
                     addLog("ğŸ’€ ä½ è¢«æ‰“è´¥äº†...", 'danger');
                }
            };

            // Helper to render dynamic status bars
            const renderStats = () => {
                const statKeys = Object.keys(player.stats);
                // Find "bar" stats: keys that have a corresponding "maxKey" (e.g. hp/maxHp, mp/maxMp)
                const barStats = [];
                const otherStats = [];

                statKeys.forEach(key => {
                    if (key.startsWith('max')) return; // Skip max keys
                    const maxKey = "max" + key.charAt(0).toUpperCase() + key.slice(1);
                    if (player.stats[maxKey] !== undefined) {
                        barStats.push({ key, maxKey, label: key.toUpperCase() });
                    } else {
                        otherStats.push({ key, label: key.toUpperCase() });
                    }
                });

                return (
                    <>
                        {/* Bars */}
                        {barStats.map(stat => (
                            <div key={stat.key} className="mb-2">
                                <div className="flex justify-between text-xs uppercase text-gray-400 mb-1">
                                    <span>{stat.key}</span>
                                    <span>{Math.floor(player.stats[stat.key])}/{player.stats[stat.maxKey]}</span>
                                </div>
                                <div className="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                                    <div 
                                        className={`h-full transition-all duration-500 ${
                                            stat.key === 'hp' ? 'bg-green-500' : 
                                            stat.key === 'mp' ? 'bg-blue-500' : 
                                            stat.key === 'stamina' ? 'bg-yellow-500' : 'bg-purple-500'
                                        }`} 
                                        style={{ width: `${Math.min(100, Math.max(0, (player.stats[stat.key] / player.stats[stat.maxKey]) * 100))}%` }}
                                    ></div>
                                </div>
                            </div>
                        ))}
                        
                        {/* Grid for other stats */}
                        <div className="grid grid-cols-3 gap-2 mt-3 text-sm text-gray-400">
                            {otherStats.map(stat => (
                                <div key={stat.key} className="flex flex-col items-center bg-gray-700/30 rounded p-1">
                                    <span className="text-xs text-gray-500 uppercase">{stat.key}</span>
                                    <span className="font-bold text-gray-200">{player.stats[stat.key]}</span>
                                </div>
                            ))}
                        </div>
                    </>
                );
            };

            // Helper to make element draggable
            const Draggable = ({ children, initialPos }) => {
                const [pos, setPos] = useState(initialPos || { x: 0, y: 0 });
                const [dragging, setDragging] = useState(false);
                const [rel, setRel] = useState(null);

                const onMouseDown = (e) => {
                    if (e.button !== 0) return;
                    setDragging(true);
                    setRel({
                        x: e.pageX - pos.x,
                        y: e.pageY - pos.y
                    });
                    e.stopPropagation();
                    e.preventDefault();
                };

                const onMouseUp = () => {
                    setDragging(false);
                };

                const onMouseMove = (e) => {
                    if (!dragging) return;
                    setPos({
                        x: e.pageX - rel.x,
                        y: e.pageY - rel.y
                    });
                    e.stopPropagation();
                    e.preventDefault();
                };

                // Global mouse events for smoother dragging
                useEffect(() => {
                    if (dragging) {
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    } else {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    }
                    return () => {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };
                }, [dragging]);

                return (
                    <div 
                        onMouseDown={onMouseDown}
                        style={{
                            position: 'fixed',
                            left: pos.x + 'px',
                            top: pos.y + 'px',
                            zIndex: 1000,
                            cursor: dragging ? 'grabbing' : 'grab'
                        }}
                    >
                        {children}
                    </div>
                );
            };

            return (
                <div className="flex flex-col h-screen max-w-7xl mx-auto p-2 md:p-4">
                    {/* Dice Overlay (Floating & Draggable) */}
                    {showDice && (
                        <Draggable initialPos={{ x: window.innerWidth - 250, y: window.innerHeight - 200 }}>
                            <div className="bg-gray-800 p-3 rounded border border-purple-500 shadow-xl flex flex-col gap-2 w-64">
                                <div className="flex justify-between items-center cursor-grab active:cursor-grabbing border-b border-gray-700 pb-1 mb-1">
                                    <span className="text-xs text-purple-300 font-bold select-none">ğŸ² æ·éª°å™¨ (æ‹–åŠ¨æˆ‘)</span>
                                    <button onClick={() => setShowDice(false)} className="text-gray-500 hover:text-white px-1">Ã—</button>
                                </div>
                                <div className="flex gap-2">
                                    <input 
                                        type="text" 
                                        value={diceExpression}
                                        onChange={(e) => setDiceExpression(e.target.value)}
                                        onMouseDown={(e) => e.stopPropagation()} // Prevent drag on input
                                        className="flex-1 p-1 text-sm rounded bg-gray-700 border border-gray-600 text-white"
                                        placeholder="1d20"
                                    />
                                    <button 
                                        onClick={handleRollDice}
                                        onMouseDown={(e) => e.stopPropagation()}
                                        className="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded text-sm font-bold"
                                    >
                                        Roll
                                    </button>
                                </div>
                                <div className="flex gap-1 justify-between">
                                    {["1d20", "2d6", "1d100"].map(exp => (
                                        <button 
                                            key={exp}
                                            onClick={() => setDiceExpression(exp)}
                                            onMouseDown={(e) => e.stopPropagation()}
                                            className="text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 px-2 py-0.5 rounded"
                                        >
                                            {exp}
                                        </button>
                                    ))}
                                </div>
                            </div>
                        </Draggable>
                    )}

                    {/* Top Bar with Save/Load */}
                    <div className="flex justify-end gap-2 mb-2 shrink-0">
                        <input 
                            type="file" 
                            ref={fileInputRef}
                            onChange={handleImportFile}
                            style={{ display: 'none' }}
                            accept=".json"
                        />
                        <button 
                            onClick={handleImportClick}
                            className="px-3 py-1 text-xs md:text-sm bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 flex items-center gap-1 transition-colors"
                            title="å¯¼å…¥ä¹‹å‰çš„æ¸¸æˆè®°å½•"
                        >
                            ğŸ“‚ å¯¼å…¥è®°å½•
                        </button>
                        <button 
                            onClick={handleExport}
                            className="px-3 py-1 text-xs md:text-sm bg-gray-700 hover:bg-gray-600 text-gray-300 rounded border border-gray-600 flex items-center gap-1 transition-colors"
                            title="ä¿å­˜å½“å‰æ¸¸æˆè®°å½•åˆ°æœ¬åœ°"
                        >
                            ğŸ’¾ å¯¼å‡ºè®°å½•
                        </button>
                    </div>

                    {/* Main Game Layout */}
                    <div className="flex-1 flex flex-col lg:flex-row gap-4 overflow-hidden">
                        
                        {/* LEFT PANEL: Player Stats */}
                        <div className="lg:w-72 shrink-0 flex flex-col gap-4 overflow-y-auto lg:overflow-y-visible">
                            <div className="bg-gray-800 p-4 rounded border border-gray-600 relative">
                                <div className="flex justify-between items-center mb-3">
                                    <h2 className="text-xl font-bold text-purple-400">{player.name}</h2>
                                    <div className="flex gap-2">
                                        <button 
                                            onClick={() => setShowInventory(!showInventory)}
                                            className="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded text-gray-300 flex items-center gap-1"
                                        >
                                            ğŸ’ ç‰©å“ ({player.items ? player.items.length : 0})
                                        </button>
                                        <span className="text-xs bg-gray-700 px-2 py-1 rounded text-gray-300">{player.class}</span>
                                    </div>
                                </div>
                                
                                {renderStats()}

                                {/* Buffs Section */}
                                {player.buffs && player.buffs.length > 0 && (
                                    <div className="mt-4">
                                        <h3 className="text-xs font-bold text-purple-400 uppercase mb-2">å½“å‰çŠ¶æ€ (Buffs)</h3>
                                        <div className="flex flex-wrap gap-2">
                                            {player.buffs.map((buff, i) => (
                                                <div key={i} className="text-xs bg-blue-900/50 border border-blue-500 px-2 py-1 rounded text-blue-200 cursor-help" title={`${buff.description || buff.effect} (å‰©ä½™: ${buff.duration} å›åˆ)`}>
                                                    {buff.name}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {/* Inventory Overlay - Adjusted for sidebar */}
                                {showInventory && (
                                    <div className="absolute top-12 left-0 lg:left-full lg:top-0 lg:ml-2 w-64 bg-gray-900 border border-gray-500 rounded shadow-xl z-50 max-h-80 overflow-y-auto">
                                        <div className="p-2 border-b border-gray-700 flex justify-between items-center bg-gray-800">
                                            <span className="text-sm font-bold text-gray-200">èƒŒåŒ…</span>
                                            <button onClick={() => setShowInventory(false)} className="text-gray-500 hover:text-white">Ã—</button>
                                        </div>
                                        <div className="p-2 space-y-2">
                                            {player.items && player.items.length > 0 ? (
                                                player.items.map((item, idx) => (
                                                    <div key={idx} className="bg-gray-800 p-2 rounded border border-gray-700 text-sm">
                                                        <div className="flex justify-between">
                                                            <span className="font-bold text-purple-300">{item.name}</span>
                                                            <span className="text-gray-400">x{item.count}</span>
                                                        </div>
                                                        <p className="text-xs text-gray-500 mb-1">{item.description}</p>
                                                        {item.type === 'consumable' && (
                                                            <button 
                                                                onClick={() => handleUseItem(idx)}
                                                                className="w-full bg-green-800 hover:bg-green-700 text-green-100 text-xs py-1 rounded"
                                                            >
                                                                ä½¿ç”¨
                                                            </button>
                                                        )}
                                                    </div>
                                                ))
                                            ) : (
                                                <div className="text-center text-gray-500 py-4 text-xs">èƒŒåŒ…æ˜¯ç©ºçš„</div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* CENTER PANEL: Main Game Area (Logs + Input) */}
                        <div className="flex-1 flex flex-col gap-4 overflow-hidden min-w-0 order-last lg:order-none">
                            {/* Log/Narrative Area */}
                            <div 
                                ref={logContainerRef}
                                className="flex-1 bg-gray-900 p-4 rounded border border-gray-700 overflow-y-auto space-y-2 font-mono text-sm md:text-base shadow-inner relative"
                            >
                                {logs.map((log, i) => (
                                    <div key={i} className={`p-2 rounded leading-relaxed ${
                                        log.type === 'narrative' ? 'bg-gray-800 text-yellow-100 border-l-2 border-yellow-600' :
                                        log.type === 'combat' ? 'bg-red-900/20 text-red-100 border-l-2 border-red-600' :
                                        log.type === 'action' ? 'bg-gray-700/50 text-gray-300 text-right italic' :
                                        log.type === 'success' ? 'bg-green-900/30 text-green-200 border-l-2 border-green-500' :
                                        log.type === 'danger' ? 'bg-red-600 text-white font-bold text-center' :
                                        'text-gray-300'
                                    }`}>
                                        {log.text}
                                    </div>
                                ))}
                                {processing && (
                                    <div className="flex items-center gap-2 text-gray-400 italic p-2">
                                        <span className="animate-spin">âœ¦</span> AI æ­£åœ¨ç”Ÿæˆ...
                                    </div>
                                )}
                            </div>

                            {/* Input / Controls Area */}
                            <div className="bg-gray-800 p-4 rounded border border-gray-600 shadow-lg z-10">
                                {phase === 'adventure' ? (
                                    // Adventure Controls
                                    <div className="flex gap-2">
                                        <button
                                            onClick={() => setShowDice(!showDice)}
                                            className={`px-3 rounded border ${showDice ? 'bg-purple-700 border-purple-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400 hover:bg-gray-600'}`}
                                            title="æ‰“å¼€æ·éª°å™¨"
                                        >
                                            ğŸ²
                                        </button>
                                        <input
                                            type="text"
                                            value={inputAction}
                                            onChange={(e) => setInputAction(e.target.value)}
                                            onKeyDown={(e) => e.key === 'Enter' && handleAdventureAction()}
                                            placeholder="è¾“å…¥ä½ çš„è¡ŒåŠ¨ (ä¾‹å¦‚: å‘åŒ—æ¢ç´¢ï¼Œå¯»æ‰¾æ°´æºï¼Œè°ƒæŸ¥ç¥åº™...)"
                                            className="flex-1 p-3 rounded bg-gray-700 border border-gray-600 focus:border-purple-500 focus:outline-none text-white"
                                            disabled={processing}
                                        />
                                        <button
                                            onClick={handleAdventureAction}
                                            disabled={processing || !inputAction.trim()}
                                            className="px-6 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded shadow disabled:opacity-50"
                                        >
                                            è¡ŒåŠ¨
                                        </button>
                                    </div>
                                ) : (
                                    // Combat Controls
                                    <div className="space-y-3">
                                        <div className="flex justify-between items-center text-xs text-gray-400 uppercase tracking-wider">
                                            <div className="flex items-center gap-3">
                                                <span>æˆ˜æ–—æ¨¡å¼</span>
                                                <label className="flex items-center gap-1 cursor-pointer hover:text-gray-300" title="å¼€å¯/å…³é—­ AI æˆ˜æ–—è§£è¯´">
                                                     <input 
                                                        type="checkbox" 
                                                        checked={showNarrative} 
                                                        onChange={(e) => setShowNarrative(e.target.checked)} 
                                                        className="accent-purple-500" 
                                                    />
                                                     <span>è§£è¯´</span>
                                                </label>
                                                <label className="flex items-center gap-1 cursor-pointer hover:text-gray-300 text-blue-400" title="ä½¿ç”¨ JavaScript è¿›è¡Œç¡®å®šæ€§ä¼¤å®³è®¡ç®—ï¼Œè€Œé AI ä¼°ç®—">
                                                     <input 
                                                        type="checkbox" 
                                                        checked={useJsCombat} 
                                                        onChange={(e) => setUseJsCombat(e.target.checked)} 
                                                        className="accent-blue-500" 
                                                    />
                                                     <span>JSä¼¤å®³</span>
                                                </label>
                                            </div>
                                            <div className="flex gap-2 items-center">
                                                <button 
                                                    onClick={() => setShowDice(!showDice)}
                                                    className="text-purple-400 hover:text-purple-300 flex items-center gap-1"
                                                >
                                                    <span>ğŸ² æ·éª°å™¨</span>
                                                </button>
                                                <span>å½“å‰ç›®æ ‡: {enemies[selectedTargetIndex]?.name || "æ— "}</span>
                                            </div>
                                        </div>
                                        
                                        {/* Skills */}
                                        <div className="flex flex-col gap-2">
                                            {/* Active Skills */}
                                            <div className="flex gap-2 flex-wrap">
                                                {player.skills.filter(s => s.type !== 'passive').map((skill, i) => (
                                                    <button
                                                        key={i}
                                                        onClick={() => handleCombatAction('skill', skill)}
                                                        disabled={processing || player.stats.hp <= 0}
                                                        className="flex flex-col items-start px-3 py-2 bg-red-700 hover:bg-red-600 text-white rounded shadow border-b-4 border-red-900 active:border-0 active:translate-y-1 disabled:opacity-50 disabled:translate-y-0 disabled:border-b-4 min-w-[120px]"
                                                        title={`${skill.name}\nç±»å‹: ${skill.type === 'active' ? 'ä¸»åŠ¨' : 'è¢«åŠ¨'}\næ¶ˆè€—: ${skill.cost} ${skill.costType}\nä¼¤å®³/å¼ºåº¦: ${skill.damage}\nç›®æ ‡: ${skill.target}\næ•ˆæœ: ${skill.statusEffects ? skill.statusEffects.join(',') : 'æ— '}\n\n${skill.description}`}
                                                    >
                                                        <span className="font-bold text-sm">{skill.name}</span>
                                                        <div className="flex gap-1 text-[10px] opacity-80 mt-1">
                                                            {skill.cost > 0 && <span>{skill.cost}{skill.costType}</span>}
                                                            {skill.target && <span className="bg-black/30 px-1 rounded">{skill.target === 'aoe' ? 'èŒƒå›´' : skill.target === 'self' ? 'è‡ªèº«' : 'å•ä½“'}</span>}
                                                        </div>
                                                    </button>
                                                ))}
                                            </div>
                                            
                                            {/* Passive Skills */}
                                            {player.skills.some(s => s.type === 'passive') && (
                                                <div className="bg-gray-700/50 p-2 rounded border border-gray-600 flex flex-wrap gap-2">
                                                    <span className="text-xs text-gray-400 uppercase font-bold">è¢«åŠ¨æŠ€èƒ½:</span>
                                                    {player.skills.filter(s => s.type === 'passive').map((skill, i) => (
                                                        <div key={i} className="text-xs bg-gray-800 px-2 py-1 rounded text-gray-300 border border-gray-700 cursor-help" title={`${skill.name}\n${skill.description}`}>
                                                            {skill.name}
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>

                                        {/* Custom Combat Action */}
                                        <div className="flex gap-2">
                                            <input
                                                type="text"
                                                value={inputAction}
                                                onChange={(e) => setInputAction(e.target.value)}
                                                onKeyDown={(e) => e.key === 'Enter' && handleCombatAction('custom')}
                                                placeholder="å°è¯•ç‰¹æ®Šæˆ˜æ–—è¡ŒåŠ¨ (ä¾‹å¦‚: å¯»æ‰¾æ©ä½“ï¼ŒæŠ•æ·æ²™çŸ³...)"
                                                className="flex-1 p-2 rounded bg-gray-700 border border-gray-600 focus:border-red-500 focus:outline-none text-white text-sm"
                                                disabled={processing}
                                            />
                                            <button
                                                onClick={() => handleCombatAction('custom')}
                                                disabled={processing || !inputAction.trim()}
                                                className="px-4 bg-gray-600 hover:bg-gray-500 text-white text-sm font-bold rounded disabled:opacity-50"
                                            >
                                                æ‰§è¡Œ
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* RIGHT PANEL: Enemy List (Combat) */}
                        <div className={`lg:w-72 shrink-0 flex flex-col gap-4 ${phase !== 'combat' ? 'hidden lg:flex lg:invisible' : ''}`}>
                            {phase === 'combat' && (
                                <div className="bg-gray-800 p-4 rounded border border-gray-600 overflow-y-auto max-h-60 lg:max-h-full">
                                    <h3 className="text-sm font-bold text-red-400 mb-2 sticky top-0 bg-gray-800">æ•Œäººåˆ—è¡¨ (ç‚¹å‡»é€‰æ‹©ç›®æ ‡)</h3>
                                    <div className="space-y-2">
                                        {enemies.map((enemy, idx) => (
                                            <div 
                                                key={idx}
                                                onClick={() => setSelectedTargetIndex(idx)}
                                                title={`${enemy.description || ''}\n${enemy.traits ? "ç‰¹æ€§: " + enemy.traits.map(t => t.name + "(" + t.description + ")").join(", ") : ""}\n${enemy.skills ? "æŠ€èƒ½: " + enemy.skills.join(", ") : ""}`}
                                                className={`p-2 rounded border cursor-pointer transition-colors ${
                                                    selectedTargetIndex === idx 
                                                    ? 'bg-red-900/40 border-red-500' 
                                                    : 'bg-gray-700/50 border-transparent hover:bg-gray-700'
                                                }`}
                                            >
                                                <div className="flex justify-between items-center">
                                                    <span className={selectedTargetIndex === idx ? "text-red-300 font-bold" : "text-gray-300"}>
                                                        {enemy.name}
                                                    </span>
                                                    <div className="flex flex-col items-end">
                                                        <span className="text-xs text-gray-400">HP: {Math.floor(enemy.stats.hp)}/{enemy.stats.maxHp}</span>
                                                        {enemy.buffs && enemy.buffs.length > 0 && (
                                                            <div className="flex gap-1 mt-1">
                                                                {enemy.buffs.map((b, bi) => (
                                                                    <span key={bi} className="w-2 h-2 rounded-full bg-yellow-500" title={`${b.name}: ${b.description}`}></span>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                                <div className="w-full bg-gray-900 rounded-full h-1.5 mt-1">
                                                    <div 
                                                        className="bg-red-500 h-full rounded-full transition-all duration-500" 
                                                        style={{ width: `${Math.min(100, (enemy.stats.hp / enemy.stats.maxHp) * 100)}%` }}
                                                    ></div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>

                    </div>
                </div>
            );
        }

        function App() {
            const [gameConfig, setGameConfig] = useState(null);
            const [character, setCharacter] = useState(null);

            const handleConnect = (config) => {
                setGameConfig(config);
            };

            if (!gameConfig) {
                return <ConfigScreen onConnect={handleConnect} />;
            }

            return (
                <>
                    {!character ? (
                        <CharacterCreation onCharacterCreated={setCharacter} config={gameConfig} />
                    ) : (
                        <GameInterface character={character} config={gameConfig} />
                    )}
                </>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
